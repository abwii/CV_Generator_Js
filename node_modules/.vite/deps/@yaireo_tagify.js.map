{
  "version": 3,
  "sources": ["../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/constants.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/helpers.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/defaults.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/dropdown.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/suggestions.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/persist.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/texts.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/templates.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/events.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/tagify.js", "../../../frontend/node_modules/@yaireo/tagify/dist/src/parts/EventDispatcher.js"],
  "sourcesContent": ["export var ZERO_WIDTH_CHAR = '\\u200B';\nexport var ZERO_WIDTH_UNICODE_CHAR = `&#8203;`", "import {ZERO_WIDTH_CHAR} from './constants'\n\nexport const logger = {\n    isEnabled() { return window.TAGIFY_DEBUG ?? true},\n    log(...args){ this.isEnabled() && console.log('[Tagify]:', ...args) },\n    warn(...args) { this.isEnabled() && console.warn('[Tagify]:', ...args) }\n}\n\n// console.json = console.json || function(argument){\n//     for(var arg=0; arg < arguments.length; ++arg)\n//         console.log(  JSON.stringify(arguments[arg], null, 4)  )\n// }\n\n// const isEdge = /Edge/.test(navigator.userAgent)\nexport const sameStr = (s1, s2, caseSensitive, trim) => {\n    // cast to String\n    s1 = \"\"+s1;\n    s2 = \"\"+s2;\n\n    if( trim ){\n        s1 = s1.trim()\n        s2 = s2.trim()\n    }\n\n    return caseSensitive\n        ? s1 == s2\n        : s1.toLowerCase() == s2.toLowerCase()\n}\n\n\n// const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)\nexport const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps))\n\nexport function omit(obj, props){\n    var newObj = {}, p;\n    for( p in obj )\n        if( props.indexOf(p) < 0 )\n            newObj[p] = obj[p]\n    return newObj\n}\n\nexport function decode( s ) {\n    var el = document.createElement('div');\n    return s.replace(/\\&#?[0-9a-z]+;/gi, function(enc){\n        el.innerHTML = enc;\n        return el.innerText\n    })\n}\n\n/**\n * utility method\n * https://stackoverflow.com/a/35385518/104380\n * @param  {String} s [HTML string]\n * @return {Object}   [DOM node]\n */\nexport function parseHTML( s ){\n    var parser = new DOMParser(),\n        node   = parser.parseFromString(s.trim(), \"text/html\");\n\n    return node.body.firstElementChild;\n}\n\n/**\n * Removed new lines and irrelevant spaces which might affect layout, and are better gone\n * @param {string} s [HTML string]\n */\nexport function minify( s ){\n    return s ? s\n        .replace(/\\>[\\r\\n ]+\\</g, \"><\")\n        .split(/>\\s+</).join('><').trim()\n        : \"\"\n}\n\nexport function removeTextChildNodes( elm ){\n    var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),\n        textnode;\n\n    // print all text nodes\n    while (textnode = iter.nextNode()){\n        if( !textnode.textContent.trim() )\n            textnode.parentNode.removeChild(textnode)\n    }\n}\n\nexport function getfirstTextNode( elm, action ){\n    action = action || 'previous';\n    while ( elm = elm[action + 'Sibling'] )\n        if( elm.nodeType == 3 )\n            return elm\n}\n\n/**\n * utility method\n * https://stackoverflow.com/a/6234804/104380\n */\nexport function escapeHTML( s ){\n    return typeof s == 'string' ? s\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/`|'/g, \"&#039;\")\n        : s;\n}\n\n/**\n * Checks if an argument is a javascript Object\n */\nexport function isObject(obj) {\n    var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);\n    return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';\n}\n\n/**\n * merge objects into a single new one\n * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})\n */\nexport function extend( o, o1, o2) {\n    if( !(o instanceof Object) ) o = {};\n\n    copy(o, o1);\n    if( o2 )\n        copy(o, o2)\n\n    function copy(a,b){\n        // copy o2 to o\n        for( var key in b )\n            if( b.hasOwnProperty(key) ){\n                if( isObject(b[key]) ){\n                    if( !isObject(a[key]) )\n                        a[key] = Object.assign({}, b[key])\n                    else\n                        copy(a[key], b[key])\n\n                    continue;\n                }\n\n                if( Array.isArray(b[key]) ){\n                    a[key] = Object.assign([], b[key])\n                    continue\n                }\n\n                a[key] = b[key]\n            }\n    }\n\n    return o\n}\n\n/**\n * concatenates N arrays without dups.\n * If an array's item is an Object, compare by `value`\n */\nexport function concatWithoutDups(){\n    const newArr = [],\n        existingObj = {};\n\n    for( let arr of arguments ) {\n        for( let item of arr ) {\n            // if current item is an object which has yet to be added to the new array\n            if( isObject(item) ){\n                if( !existingObj[item.value] ){\n                    newArr.push(item)\n                    existingObj[item.value] = 1\n                }\n            }\n\n            // if current item is not an object and is not in the new array\n            else if( !newArr.includes(item) )\n                newArr.push(item)\n        }\n    }\n\n    return newArr\n}\n\n/**\n *  Extracted from: https://stackoverflow.com/a/37511463/104380\n * @param {String} s\n */\nexport function unaccent( s ){\n    // if not supported, do not continue.\n    // developers should use a polyfill:\n    // https://github.com/walling/unorm\n    if( !String.prototype.normalize )\n        return s\n\n    if (typeof(s) === 'string')\n        return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\n/**\n * Meassures an element's height, which might yet have been added DOM\n * https://stackoverflow.com/q/5944038/104380\n * @param {DOM} node\n */\nexport function getNodeHeight( node ){\n    var height, clone = node.cloneNode(true)\n    clone.style.cssText = \"position:fixed; top:-9999px; opacity:0\"\n    document.body.appendChild(clone)\n    height = clone.clientHeight\n    clone.parentNode.removeChild(clone)\n    return height\n}\n\nexport var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent)\n\nexport function getUID() {\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    )\n}\n\nexport function isNodeTag(node){\n    return node && node.classList && node.classList.contains(this.settings.classNames.tag)\n}\n\nexport function isWithinNodeTag(node){\n    return node && node.closest(this.settings.classNames.tagSelector)\n}\n\n/**\n* Get the caret position relative to the viewport\n* https://stackoverflow.com/q/58985076/104380\n*\n* @returns {object} left, top distance in pixels\n*/\nexport function getCaretGlobalPosition(){\n   const sel = document.getSelection()\n\n   if( sel.rangeCount ){\n       const r = sel.getRangeAt(0)\n       const node = r.startContainer\n       const offset = r.startOffset\n       let rect,  r2;\n\n       if (offset > 0) {\n           r2 = document.createRange()\n           r2.setStart(node, offset - 1)\n           r2.setEnd(node, offset)\n           rect = r2.getBoundingClientRect()\n           return {left:rect.right, top:rect.top, bottom:rect.bottom}\n       }\n\n       if( node.getBoundingClientRect )\n           return node.getBoundingClientRect()\n   }\n\n   return {left:-9999, top:-9999}\n}\n\n/**\n * Injects content (either string or node) at the current the current (or specificed) caret position\n * @param {content} string/node\n * @param {range} Object (optional, a range other than the current window selection)\n */\nexport function injectAtCaret(content, range){\n    var selection = window.getSelection();\n    range = range || selection.getRangeAt(0)\n\n    if( typeof content == 'string' )\n        content = document.createTextNode(content)\n\n    if( range ) {\n        range.deleteContents()\n        range.insertNode(content)\n    }\n\n    return content\n}\n\n/** Setter/Getter\n * Each tag DOM node contains a custom property called \"__tagifyTagData\" which hosts its data\n * @param {Node}   tagElm\n * @param {Object} data\n */\nexport function getSetTagData(tagElm, data, override){\n    if( !tagElm ){\n        logger.warn(\"tag element doesn't exist\",{tagElm, data})\n        return data\n    }\n\n    if( data )\n        tagElm.__tagifyTagData = override\n            ? data\n            : extend({}, tagElm.__tagifyTagData || {}, data)\n\n    return tagElm.__tagifyTagData\n}\n\nexport function placeCaretAfterNode( node ){\n    if( !node || !node.parentNode ) return\n\n    var nextSibling = node,\n        sel = window.getSelection(),\n        range = sel.getRangeAt(0);\n\n    if (sel.rangeCount) {\n        range.setStartAfter(nextSibling);\n        range.collapse(true)\n        // range.setEndBefore(nextSibling || node);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n}\n\n/**\n * iterate all tags, checking if multiple ones are close-siblings and if so, add a zero-space width character between them,\n * which forces the caret to be rendered when the selection is between tags.\n * Also do that if the tag is the first node.\n * @param {Array} tags\n */\nexport function fixCaretBetweenTags(tags, TagifyHasFocuse) {\n    tags.forEach(tag => {\n        if( getSetTagData(tag.previousSibling) || !tag.previousSibling ) {\n            var textNode = document.createTextNode(ZERO_WIDTH_CHAR)\n            tag.before(textNode)\n            TagifyHasFocuse && placeCaretAfterNode(textNode)\n        }\n    })\n}\n\n", "export default {\r\n    delimiters          : \",\",            // [RegEx] split tags by any of these delimiters (\"null\" to cancel) Example: \",| |.\"\r\n    pattern             : null,           // RegEx pattern to validate input by. Ex: /[1-9]/\r\n    tagTextProp         : 'value',        // tag data Object property which will be displayed as the tag's text\r\n    maxTags             : Infinity,       // Maximum number of tags\r\n    callbacks           : {},             // Exposed callbacks object to be triggered on certain events\r\n    addTagOnBlur        : true,           // automatically adds the text which was inputed as a tag when blur event happens\r\n    addTagOn            : ['blur', 'tab', 'enter'],  // if the tagify field (in a normal mode) has any non-tag input in it, convert it to a tag on any of these events: blur away from the field, click \"tab\"/\"enter\" key\r\n    onChangeAfterBlur   : true,           // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.\r\n    duplicates          : false,          // \"true\" - allow duplicate tags\r\n    whitelist           : [],             // Array of tags to suggest as the user types (can be used along with \"enforceWhitelist\" setting)\r\n    blacklist           : [],             // A list of non-allowed tags\r\n    enforceWhitelist    : false,          // Only allow tags from the whitelist\r\n    userInput           : true,           // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)\r\n    focusable           : true,           // Allow the component as a whole to recieve focus. There are implementations of Tagify without external border and so 'focusability' causes unwanted behaviour\r\n    keepInvalidTags     : false,          // if true, do not remove tags which did not pass validation\r\n    createInvalidTags   : true,           // if false, do not create invalid tags from invalid user input\r\n    mixTagsAllowedAfter : /,|\\.|\\:|\\s/,   // RegEx - Define conditions in which mix-tags content allows a tag to be added after\r\n    mixTagsInterpolator : ['[[', ']]'],   // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object\r\n    backspace           : true,           // false / true / \"edit\"\r\n    skipInvalid         : false,          // If `true`, do not add invalid, temporary, tags before automatically removing them\r\n    pasteAsTags         : true,           // automatically converts pasted text into tags. if \"false\", allows for further text editing\r\n\r\n    editTags            : {\r\n        clicks      : 2,                  // clicks to enter \"edit-mode\": 1 for single click. any other value is considered as double-click\r\n        keepInvalid : true                // keeps invalid edits as-is until `esc` is pressed while in focus\r\n    },              // 1 or 2 clicks to edit a tag. false/null for not allowing editing\r\n    transformTag        : ()=>{},         // Takes a tag input string as argument and returns a transformed value\r\n    trim                : true,           // whether or not the value provided should be trimmed, before being added as a tag\r\n    a11y: {\r\n        focusableTags: false\r\n    },\r\n\r\n    mixMode: {\r\n        insertAfterTag  : '\\u00A0',       // String/Node to inject after a tag has been added (see #588)\r\n    },\r\n\r\n    autoComplete: {\r\n        enabled: true,        // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text\r\n        rightKey: false,      // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to \"true\"\r\n        tabKey: false,        // If 'true`, pressing `tab` key would only auto-complete but not also convert to a tag (like `rightKey` does).\r\n    },\r\n\r\n    classNames: {\r\n        namespace            : 'tagify',\r\n        mixMode              : 'tagify--mix',\r\n        selectMode           : 'tagify--select',\r\n        input                : 'tagify__input',\r\n        focus                : 'tagify--focus',\r\n        tagNoAnimation       : 'tagify--noAnim',\r\n        tagInvalid           : 'tagify--invalid',\r\n        tagNotAllowed        : 'tagify--notAllowed',\r\n        scopeLoading         : 'tagify--loading',\r\n        hasMaxTags           : 'tagify--hasMaxTags',\r\n        hasNoTags            : 'tagify--noTags',\r\n        empty                : 'tagify--empty',\r\n        inputInvalid         : 'tagify__input--invalid',\r\n        dropdown             : 'tagify__dropdown',\r\n        dropdownWrapper      : 'tagify__dropdown__wrapper',\r\n        dropdownHeader       : 'tagify__dropdown__header',\r\n        dropdownFooter       : 'tagify__dropdown__footer',\r\n        dropdownItem         : 'tagify__dropdown__item',\r\n        dropdownItemActive   : 'tagify__dropdown__item--active',\r\n        dropdownItemHidden   : 'tagify__dropdown__item--hidden',\r\n        dropdownItemSelected : 'tagify__dropdown__item--selected',\r\n        dropdownInital       : 'tagify__dropdown--initial',\r\n        tag                  : 'tagify__tag',\r\n        tagText              : 'tagify__tag-text',\r\n        tagX                 : 'tagify__tag__removeBtn',\r\n        tagLoading           : 'tagify__tag--loading',\r\n        tagEditing           : 'tagify__tag--editable',\r\n        tagFlash             : 'tagify__tag--flash',\r\n        tagHide              : 'tagify__tag--hide',\r\n\r\n    },\r\n\r\n    dropdown: {\r\n        classname          : '',\r\n        enabled            : 2,      // minimum input characters to be typed for the suggestions dropdown to show\r\n        maxItems           : 10,\r\n        searchKeys         : [\"value\", \"searchBy\"],\r\n        fuzzySearch        : true,\r\n        caseSensitive      : false,\r\n        accentedSearch     : true,\r\n        includeSelectedTags: false,  // Should the suggestions list Include already-selected tags (after filtering)\r\n        escapeHTML         : true,   // escapes HTML entities in the suggestions' rendered text\r\n        highlightFirst     : true,   // highlights first-matched item in the list\r\n        closeOnSelect      : true,   // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)\r\n        clearOnSelect      : true,   // after selecting a suggetion, should the typed text input remain or be cleared\r\n        position           : 'all',  // 'manual' / 'text' / 'all'\r\n        appendTarget       : null    // defaults to document.body once DOM has been loaded\r\n    },\r\n\r\n    hooks: {\r\n        beforeRemoveTag: () => Promise.resolve(),\r\n        beforePaste: () => Promise.resolve(),\r\n        suggestionClick: () => Promise.resolve(),\r\n        beforeKeyDown: () => Promise.resolve(),\r\n    }\r\n}", "import { sameStr, isObject, minify, getNodeHeight, getCaretGlobalPosition } from './helpers'\r\nimport suggestionsMethods from './suggestions'\r\n\r\nexport function initDropdown(){\r\n    this.dropdown = {}\r\n\r\n    // auto-bind \"this\" to all the dropdown methods\r\n    for( let p in this._dropdown )\r\n        this.dropdown[p] = typeof this._dropdown[p] === 'function'\r\n            ? this._dropdown[p].bind(this)\r\n            : this._dropdown[p]\r\n\r\n    this.dropdown.refs()\r\n    this.DOM.dropdown.__tagify = this\r\n}\r\n\r\nexport default {\r\n    ...suggestionsMethods,\r\n\r\n    refs(){\r\n        this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings])\r\n        this.DOM.dropdown.content = this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-wrapper']\")\r\n    },\r\n\r\n    getHeaderRef(){\r\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-header']\")\r\n    },\r\n\r\n    getFooterRef(){\r\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-footer']\")\r\n    },\r\n\r\n    getAllSuggestionsRefs(){\r\n        return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)]\r\n    },\r\n\r\n    /**\r\n     * shows the suggestions select box\r\n     * @param {String} value [optional, filter the whitelist by this value]\r\n     */\r\n    show( value ){\r\n        var _s = this.settings,\r\n            firstListItem,\r\n            firstListItemValue,\r\n            allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,\r\n            noWhitelist =  !_s.whitelist || !_s.whitelist.length,\r\n            noMatchListItem,\r\n            isManual = _s.dropdown.position == 'manual';\r\n\r\n        // if text still exists in the input, and `show` method has no argument, then the input's text should be used\r\n        value = value === undefined ? this.state.inputText : value\r\n\r\n        // ⚠️ Do not render suggestions list  if:\r\n        // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed\r\n        // 2. dropdown is disabled\r\n        // 3. loader is showing (controlled outside of this code)\r\n        if( (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch)\r\n            || _s.dropdown.enable === false\r\n            || this.state.isLoading\r\n            || this.settings.readonly )\r\n            return;\r\n\r\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\r\n\r\n        // if no value was supplied, show all the \"whitelist\" items in the dropdown\r\n        // @type [Array] listItems\r\n        this.suggestedListItems = this.dropdown.filterListItems(value)\r\n\r\n        // trigger at this exact point to let the developer the chance to manually set \"this.suggestedListItems\"\r\n        if( value && !this.suggestedListItems.length ){\r\n            this.trigger('dropdown:noMatch', value)\r\n\r\n            if( _s.templates.dropdownItemNoMatch )\r\n                noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {value})\r\n        }\r\n\r\n        // if \"dropdownItemNoMatch\" was not defined, procceed regular flow.\r\n        //\r\n        if( !noMatchListItem ){\r\n            // in mix-mode, if the value isn't included in the whilelist & \"enforceWhitelist\" setting is \"false\",\r\n            // then add a custom suggestion item to the dropdown\r\n            if( this.suggestedListItems.length ){\r\n                if( value   &&   allowNewTags   &&   !this.state.editing.scope  &&  !sameStr(this.suggestedListItems[0].value, value) )\r\n                    this.suggestedListItems.unshift({value})\r\n            }\r\n            else{\r\n                if( value   &&   allowNewTags  &&  !this.state.editing.scope ){\r\n                    this.suggestedListItems = [{value}]\r\n                }\r\n                // hide suggestions list if no suggestion matched\r\n                else{\r\n                    this.input.autocomplete.suggest.call(this);\r\n                    this.dropdown.hide()\r\n                    return;\r\n                }\r\n            }\r\n\r\n            firstListItem =  this.suggestedListItems[0]\r\n            firstListItemValue = \"\"+(isObject(firstListItem) ? firstListItem.value : firstListItem)\r\n\r\n            if( _s.autoComplete && firstListItemValue ){\r\n                // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of \"fuzzysearch\" setting)\r\n                if( firstListItemValue.indexOf(value) == 0 )\r\n                    this.input.autocomplete.suggest.call(this, firstListItem)\r\n            }\r\n        }\r\n\r\n        this.dropdown.fill(noMatchListItem)\r\n\r\n        if( _s.dropdown.highlightFirst ) {\r\n            this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector))\r\n        }\r\n\r\n        // bind events, exactly at this stage of the code. \"dropdown.show\" method is allowed to be\r\n        // called multiple times, regardless if the dropdown is currently visible, but the events-binding\r\n        // should only be called if the dropdown wasn't previously visible.\r\n        if( !this.state.dropdown.visible )\r\n            // timeout is needed for when pressing arrow down to show the dropdown,\r\n            // so the key event won't get registered in the dropdown events listeners\r\n            setTimeout(this.dropdown.events.binding.bind(this))\r\n\r\n        // set the dropdown visible state to be the same as the searched value.\r\n        // MUST be set *before* position() is called\r\n        this.state.dropdown.visible = value || true\r\n        this.state.dropdown.query = value\r\n\r\n        this.setStateSelection()\r\n\r\n        // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)\r\n        if( !isManual ){\r\n            // a slight delay is needed if the dropdown \"position\" setting is \"text\", and nothing was typed in the input,\r\n            // so sadly the \"getCaretGlobalPosition\" method doesn't recognize the caret position without this delay\r\n            setTimeout(() => {\r\n                this.dropdown.position()\r\n                this.dropdown.render()\r\n            })\r\n        }\r\n\r\n        // a delay is needed because of the previous delay reason.\r\n        // this event must be fired after the dropdown was rendered & positioned\r\n        setTimeout(() => {\r\n            this.trigger(\"dropdown:show\", this.DOM.dropdown)\r\n        })\r\n    },\r\n\r\n    /**\r\n     * Hides the dropdown (if it's not managed manually by the developer)\r\n     * @param {Boolean} overrideManual\r\n     */\r\n    hide( overrideManual ){\r\n        var {scope, dropdown} = this.DOM,\r\n            isManual = this.settings.dropdown.position == 'manual' && !overrideManual;\r\n\r\n        // if there's no dropdown, this means the dropdown events aren't binded\r\n        if( !dropdown || !document.body.contains(dropdown) || isManual ) return;\r\n\r\n        window.removeEventListener('resize', this.dropdown.position)\r\n        this.dropdown.events.binding.call(this, false) // unbind all events\r\n\r\n        // if the dropdown is open, and the input (scope) is clicked,\r\n        // the dropdown should be now \"close\", and the next click (on the scope)\r\n        // should re-open it, and without a timeout, clicking to close will re-open immediately\r\n        //  clearTimeout(this.dropdownHide__bindEventsTimeout)\r\n        //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events\r\n\r\n\r\n        scope.setAttribute(\"aria-expanded\", false)\r\n        dropdown.parentNode.removeChild(dropdown)\r\n\r\n        // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input\r\n        // which casues another onFocus event, which checked \"this.state.dropdown.visible\" and see it as \"false\" and re-open the dropdown\r\n        setTimeout(() => {\r\n            this.state.dropdown.visible = false\r\n        }, 100)\r\n\r\n        this.state.dropdown.query =\r\n        this.state.ddItemData =\r\n        this.state.ddItemElm =\r\n        this.state.selection = null\r\n\r\n        // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag\r\n        // so the dropdown won't be shown on following user input for that \"tag\"\r\n        if( this.state.tag && this.state.tag.value.length ){\r\n            this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag\r\n        }\r\n\r\n        this.trigger(\"dropdown:hide\", dropdown)\r\n\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * Toggles dropdown show/hide\r\n     * @param {Boolean} show forces the dropdown to show\r\n     */\r\n    toggle(show){\r\n        this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']()\r\n    },\r\n\r\n    getAppendTarget() {\r\n        var _sd = this.settings.dropdown;\r\n        return typeof _sd.appendTarget === 'function' ? _sd.appendTarget() : _sd.appendTarget;\r\n    },\r\n\r\n    render(){\r\n        // let the element render in the DOM first, to accurately measure it.\r\n        // this.DOM.dropdown.style.cssText = \"left:-9999px; top:-9999px;\";\r\n        var ddHeight = getNodeHeight(this.DOM.dropdown),\r\n            _s = this.settings,\r\n            appendTarget = this.dropdown.getAppendTarget();\r\n\r\n        if( _s.dropdown.enabled === false ) return this;\r\n\r\n        this.DOM.scope.setAttribute(\"aria-expanded\", true)\r\n\r\n        // if the dropdown has yet to be appended to the DOM,\r\n        // append the dropdown to the body element & handle events\r\n        if( !document.body.contains(this.DOM.dropdown) ){\r\n            this.DOM.dropdown.classList.add( _s.classNames.dropdownInital )\r\n            this.dropdown.position(ddHeight)\r\n            appendTarget.appendChild(this.DOM.dropdown)\r\n\r\n            setTimeout(() =>\r\n                this.DOM.dropdown.classList.remove( _s.classNames.dropdownInital )\r\n            )\r\n        }\r\n\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * re-renders the dropdown content element (see \"dropdownContent\" in templates file)\r\n     * @param {String/Array} HTMLContent - optional\r\n     */\r\n    fill( HTMLContent ){\r\n        HTMLContent = typeof HTMLContent == 'string'\r\n            ? HTMLContent\r\n            : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems)\r\n\r\n        var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent)\r\n\r\n        this.DOM.dropdown.content.innerHTML = minify(dropdownContent)\r\n    },\r\n\r\n    /**\r\n     * Re-renders only the header & footer.\r\n     * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.\r\n     * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)\r\n     * then the header & footer should be kept in sync with the suggestions data change\r\n     */\r\n    fillHeaderFooter(){\r\n        var suggestions = this.dropdown.filterListItems(this.state.dropdown.query),\r\n            newHeaderElem = this.parseTemplate('dropdownHeader', [suggestions]),\r\n            newFooterElem = this.parseTemplate('dropdownFooter', [suggestions]),\r\n            headerRef = this.dropdown.getHeaderRef(),\r\n            footerRef = this.dropdown.getFooterRef();\r\n\r\n        newHeaderElem && headerRef?.parentNode.replaceChild(newHeaderElem, headerRef)\r\n        newFooterElem && footerRef?.parentNode.replaceChild(newFooterElem, footerRef)\r\n    },\r\n\r\n    /**\r\n     * dropdown positioning logic\r\n     * (shown above/below or next to typed text for mix-mode)\r\n     */\r\n    position( ddHeight ){\r\n        var _sd = this.settings.dropdown,\r\n            appendTarget = this.dropdown.getAppendTarget();\r\n\r\n        if( _sd.position == 'manual' || !appendTarget) return\r\n\r\n        var rect, top, bottom, left, width, ancestorsOffsets,\r\n            isPlacedAbove,\r\n            cssTop, cssLeft,\r\n            ddElm = this.DOM.dropdown,\r\n            isRTL = _sd.RTL,\r\n            isDefaultAppendTarget = appendTarget === document.body,\r\n            isSelfAppended = appendTarget === this.DOM.scope,\r\n            appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : appendTarget.scrollTop,\r\n            root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,\r\n            viewportHeight = root.clientHeight,\r\n            viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0),\r\n            positionTo = viewportWidth > 480 ? _sd.position : 'all',\r\n            ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'];\r\n\r\n        ddHeight = ddHeight || ddElm.clientHeight\r\n\r\n        function getAncestorsOffsets(p){\r\n            var top = 0, left = 0;\r\n\r\n            p = p.parentNode;\r\n\r\n            // when in element-fullscreen mode, do not go above the fullscreened-element\r\n            while(p && p != root){\r\n                top += p.offsetTop || 0\r\n                left += p.offsetLeft || 0\r\n                p = p.parentNode\r\n            }\r\n\r\n            return {top, left};\r\n        }\r\n\r\n        function getAccumulatedAncestorsScrollTop() {\r\n            var scrollTop = 0,\r\n                p = _sd.appendTarget.parentNode;\r\n\r\n            while(p){\r\n                scrollTop += p.scrollTop || 0;\r\n                p = p.parentNode\r\n            }\r\n\r\n            return scrollTop;\r\n        }\r\n\r\n        if( !this.state.dropdown.visible ) return\r\n\r\n        if( positionTo == 'text' ){\r\n            rect   = getCaretGlobalPosition()\r\n            bottom = rect.bottom\r\n            top    = rect.top\r\n            left   = rect.left\r\n            width  = 'auto'\r\n        }\r\n\r\n        else{\r\n            ancestorsOffsets = getAncestorsOffsets(appendTarget)\r\n            rect   = ddTarget.getBoundingClientRect()\r\n            top    = isSelfAppended ? -1 : rect.top - ancestorsOffsets.top\r\n            bottom = (isSelfAppended ? rect.height : rect.bottom - ancestorsOffsets.top) - 1\r\n            left   = isSelfAppended ? -1 : rect.left - ancestorsOffsets.left\r\n            width  = rect.width + 'px'\r\n        }\r\n\r\n        // if the \"append target\" isn't the default, correct the `top` variable by ignoring any scrollTop of the target's Ancestors\r\n        if( !isDefaultAppendTarget ) {\r\n            let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop()\r\n            top += accumulatedAncestorsScrollTop\r\n            bottom += accumulatedAncestorsScrollTop\r\n        }\r\n\r\n        top = Math.floor(top)\r\n        bottom = Math.ceil(bottom)\r\n\r\n        isPlacedAbove = _sd.placeAbove ?? viewportHeight - rect.bottom < ddHeight\r\n\r\n        // flip vertically if there is no space for the dropdown below the input\r\n        cssTop = (isPlacedAbove ? top : bottom) + appendTargetScrollTop;\r\n\r\n        // \"pageXOffset\" property is an alias for \"scrollX\"\r\n        cssLeft = `left: ${(left + (isRTL ? (rect.width || 0) : 0) + window.pageXOffset)}px;`\r\n\r\n       // rtl = rtl ?? viewportWidth -\r\n        ddElm.style.cssText = `${cssLeft}; top: ${cssTop}px; min-width: ${width}; max-width: ${width}`;\r\n\r\n        ddElm.setAttribute('placement', isPlacedAbove ? 'top' : 'bottom')\r\n        ddElm.setAttribute('position', positionTo)\r\n    },\r\n}\r\n", "import { isObject, escapeHTML, extend, unaccent, logger } from './helpers'\n\n\n/**\n * Tagify's dropdown suggestions-related logic\n */\n\nexport default {\n    events : {\n        /**\n         * Events should only be binded when the dropdown is rendered and removed when isn't\n         * because there might be multiple Tagify instances on a certain page\n         * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]\n         */\n        binding( bindUnbind = true ){\n            // references to the \".bind()\" methods must be saved so they could be unbinded later\n            var _CB = this.dropdown.events.callbacks,\n                // callback-refs\n                _CBR = (this.listeners.dropdown = this.listeners.dropdown || {\n                    position          : this.dropdown.position.bind(this, null),\n                    onKeyDown         : _CB.onKeyDown.bind(this),\n                    onMouseOver       : _CB.onMouseOver.bind(this),\n                    onMouseLeave      : _CB.onMouseLeave.bind(this),\n                    onClick           : _CB.onClick.bind(this),\n                    onScroll          : _CB.onScroll.bind(this),\n                }),\n                action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n            if( this.settings.dropdown.position != 'manual' ){\n                document[action]('scroll', _CBR.position, true)\n                window[action]('resize', _CBR.position)\n                window[action]('keydown', _CBR.onKeyDown)\n            }\n\n            this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver)\n            this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave)\n            this.DOM.dropdown[action]('mousedown', _CBR.onClick)\n            this.DOM.dropdown.content[action]('scroll', _CBR.onScroll)\n        },\n\n        callbacks : {\n            onKeyDown(e){\n                // ignore keys during IME composition\n                if( !this.state.hasFocus || this.state.composing )\n                    return\n\n                // get the \"active\" element, and if there was none (yet) active, use first child\n                var _s = this.settings,\n                    selectedElm = this.DOM.dropdown.querySelector(_s.classNames.dropdownItemActiveSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm),\n                    isMixMode = _s.mode == 'mix',\n                    isSelectMode = _s.mode == 'select';\n\n                _s.hooks.beforeKeyDown(e, {tagify:this})\n                    .then(result => {\n                        switch( e.key ){\n                            case 'ArrowDown' :\n                            case 'ArrowUp' :\n                            case 'Down' :  // >IE11\n                            case 'Up' : {  // >IE11\n                                e.preventDefault()\n                                var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n                                    actionUp = e.key == 'ArrowUp' || e.key == 'Up';\n\n                                if( selectedElm ) {\n                                    selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                }\n\n                                // if no element was found OR current item is not a \"real\" item, loop\n                                if( !selectedElm || !selectedElm.matches(_s.classNames.dropdownItemSelector) ){\n                                    selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];\n                                }\n\n                                this.dropdown.highlightOption(selectedElm, true)\n                                // selectedElm.scrollIntoView({inline: 'nearest', behavior: 'smooth'})\n                                break;\n                            }\n                            case 'Escape' :\n                            case 'Esc': // IE11\n                                this.dropdown.hide();\n                                break;\n\n                            case 'ArrowRight' :\n                                // do not continue if the left arrow key was pressed while typing, because assuming the user wants to bypass any of the below logic and edit the content without intervention.\n                                // also do not procceed if a tag should be created when the setting `autoComplete.rightKey` is set to `true`\n                                if( this.state.actions.ArrowLeft || _s.autoComplete.rightKey )\n                                    return\n                            case 'Tab' : {\n                                let shouldAutocompleteOnKey = !_s.autoComplete.rightKey || !_s.autoComplete.tabKey\n\n                                // in mix-mode, treat arrowRight like Enter key, so a tag will be created\n                                if( !isMixMode && !isSelectMode && selectedElm && shouldAutocompleteOnKey && !this.state.editing && selectedElmData ){\n                                    e.preventDefault() // prevents blur so the autocomplete suggestion will not become a tag\n                                    var value = this.dropdown.getMappedValue(selectedElmData)\n\n                                    this.input.autocomplete.set.call(this, value)\n                                    return false\n                                }\n                                return true\n                            }\n                            case 'Enter' : {\n                                e.preventDefault()\n\n                                _s.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                                    .then(() => {\n                                        if( selectedElm ){\n                                            this.dropdown.selectOption(selectedElm)\n                                            // highlight next option\n                                            selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                            this.dropdown.highlightOption(selectedElm)\n                                            return\n                                        }\n                                        else\n                                            this.dropdown.hide()\n\n                                        if( !isMixMode )\n                                            this.addTags(this.state.inputText.trim(), true)\n                                    })\n                                    .catch(err => logger.warn(err))\n\n                                break;\n                            }\n                            case 'Backspace' : {\n                                if( isMixMode || this.state.editing.scope ) return;\n\n                                const value = this.input.raw.call(this)\n\n                                if( value == \"\" || value.charCodeAt(0) == 8203 ){\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0)\n                                }\n                            }\n                        }\n                    })\n            },\n\n            onMouseOver(e){\n                var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector)\n                // event delegation check\n                this.dropdown.highlightOption(ddItem)\n            },\n\n            onMouseLeave(e){\n                // de-highlight any previously highlighted option\n                this.dropdown.highlightOption()\n            },\n\n            onClick(e){\n                if( e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content ) return; // allow only mouse left-clicks\n\n                var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm)\n\n                // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't run\n                this.state.actions.selectOption = true;\n                setTimeout(()=> this.state.actions.selectOption = false, 50)\n\n                this.settings.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                    .then(() => {\n                        if( selectedElm )\n                            this.dropdown.selectOption(selectedElm, e)\n                        else\n                            this.dropdown.hide()\n                    })\n                    .catch(err => logger.warn(err))\n            },\n\n            onScroll(e){\n                var elm = e.target,\n                    pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;\n\n                this.trigger(\"dropdown:scroll\", {percentage:Math.round(pos)})\n            },\n        }\n    },\n\n    /**\n     * fill data into the suggestions list\n     * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)\n     */\n    refilter( value ){\n        value = value || this.state.dropdown.query || ''\n        this.suggestedListItems = this.dropdown.filterListItems(value)\n\n        this.dropdown.fill()\n\n        if( !this.suggestedListItems.length )\n            this.dropdown.hide()\n\n        this.trigger(\"dropdown:updated\", this.DOM.dropdown)\n    },\n\n    /**\n     * Given a suggestion-item, return the data associated with it\n     * @param {HTMLElement} tagElm\n     * @returns Object\n     */\n    getSuggestionDataByNode( tagElm ){\n        var item, value = tagElm && tagElm.getAttribute('value')\n\n        for(var i = this.suggestedListItems.length; i--; ) {\n            item = this.suggestedListItems[i]\n            if( isObject(item) && item.value == value ) return item\n            // for primitive whitelist items:\n            else if( item == value ) return {value: item}\n        }\n    },\n\n    getNextOrPrevOption(selected, next = true) {\n        var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n            selectedIdx = dropdownItems.findIndex(item => item === selected);\n\n        return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1]\n    },\n\n    /**\n     * mark the currently active suggestion option\n     * @param {Object}  elm            option DOM node\n     * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element\n     */\n    highlightOption( elm, adjustScroll ){\n        var className = this.settings.classNames.dropdownItemActive,\n            itemData;\n\n        // focus casues a bug in Firefox with the placeholder been shown on the input element\n        // if( this.settings.dropdown.position != 'manual' )\n        //     elm.focus();\n\n        if( this.state.ddItemElm ){\n            this.state.ddItemElm.classList.remove(className)\n            this.state.ddItemElm.removeAttribute(\"aria-selected\")\n        }\n\n        if( !elm ){\n            this.state.ddItemData = null\n            this.state.ddItemElm = null\n            this.input.autocomplete.suggest.call(this)\n            return;\n        }\n\n        itemData = this.dropdown.getSuggestionDataByNode(elm)\n        this.state.ddItemData = itemData\n        this.state.ddItemElm = elm\n\n        // this.DOM.dropdown.querySelectorAll(\".\" + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));\n        elm.classList.add(className);\n        elm.setAttribute(\"aria-selected\", true)\n\n        if( adjustScroll )\n            elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight\n\n        // Try to autocomplete the typed value with the currently highlighted dropdown item\n        if( this.settings.autoComplete ){\n            this.input.autocomplete.suggest.call(this, itemData)\n            this.dropdown.position() // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line\n        }\n    },\n\n    /**\n     * Create a tag from the currently active suggestion option\n     * @param {Object} elm  DOM node to select\n     * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)\n     */\n    selectOption( elm, event ){\n        var _s = this.settings,\n            {clearOnSelect, closeOnSelect} = _s.dropdown;\n\n        if( !elm ) {\n            this.addTags(this.state.inputText, true)\n            closeOnSelect && this.dropdown.hide()\n            return;\n        }\n\n        event = event || {}\n\n        // if in edit-mode, do not continue but instead replace the tag's text.\n        // the scenario is that \"addTags\" was called from a dropdown suggested option selected while editing\n\n        var value = elm.getAttribute('value'),\n            isNoMatch = value == 'noMatch',\n            isMixMode = _s.mode == 'mix',\n            tagData = this.suggestedListItems.find(item => (item.value ?? item) == value)\n\n        // The below event must be triggered, regardless of anything else which might go wrong\n        this.trigger('dropdown:select', {data:tagData, elm, event})\n\n        if( !tagData && !isNoMatch ){\n            closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n            return\n        }\n\n        if( this.state.editing ) {\n            let normalizedTagData = this.normalizeTags([tagData])[0]\n            tagData =  _s.transformTag.call(this, normalizedTagData) || normalizedTagData\n\n            // normalizing value, because \"tagData\" might be a string, and therefore will not be able to extend the object\n            this.onEditTagDone(null, extend({__isValid: true}, tagData))\n        }\n        // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing\n        else {\n            this[isMixMode ? \"addMixTags\" : \"addTags\"]([tagData || this.input.raw.call(this)], clearOnSelect)\n        }\n\n        if( !isMixMode && !this.DOM.input.parentNode )\n            return\n\n        setTimeout(() => {\n            this.DOM.input.focus()\n            this.toggleFocusClass(true)\n        })\n\n        closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n\n        // execute these tasks once a suggestion has been selected\n        elm.addEventListener('transitionend', () => {\n            this.dropdown.fillHeaderFooter()\n            setTimeout(() => {\n                elm.remove()\n                this.dropdown.refilter()\n            }, 100)\n        }, {once: true})\n\n        // hide selected suggestion\n        elm.classList.add(this.settings.classNames.dropdownItemHidden)\n    },\n\n    // adds all the suggested items, including the ones which are not currently rendered,\n    // unless specified otherwise (by the \"onlyRendered\" argument)\n    selectAll( onlyRendered ){\n        // having suggestedListItems with items messes with \"normalizeTags\" when wanting\n        // to add all tags\n        this.suggestedListItems.length = 0;\n        this.dropdown.hide()\n\n        this.dropdown.filterListItems('');\n\n        var tagsToAdd = this.dropdown.filterListItems('');\n\n        if( !onlyRendered )\n            tagsToAdd = this.state.dropdown.suggestions\n\n        // some whitelist items might have already been added as tags so when addings all of them,\n        // skip adding already-added ones, so best to use \"filterListItems\" method over \"settings.whitelist\"\n        this.addTags(tagsToAdd, true)\n        return this\n    },\n\n    /**\n     * returns an HTML string of the suggestions' list items\n     * @param {String} value string to filter the whitelist by\n     * @param {Object} options \"exact\" - for exact complete match\n     * @return {Array} list of filtered whitelist items according to the settings provided and current value\n     */\n    filterListItems( value, options ){\n        var _s = this.settings,\n            _sd = _s.dropdown,\n            options = options || {},\n            list = [],\n            exactMatchesList = [],\n            whitelist = _s.whitelist,\n            suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity,\n            includeSelectedTags = _sd.includeSelectedTags || _s.mode == 'select',\n            searchKeys = _sd.searchKeys,\n            whitelistItem,\n            valueIsInWhitelist,\n            searchBy,\n            isDuplicate,\n            niddle,\n            i = 0;\n\n        value = (_s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value\n            ? '' // do not filter if the tag, which is already selecetd in \"select\" mode, is the same as the typed text\n            : value);\n\n        if( !value || !searchKeys.length ){\n            list = includeSelectedTags\n                ? whitelist\n                : whitelist.filter(item => !this.isTagDuplicate( isObject(item) ? item.value : item )) // don't include tags which have already been added.\n\n            this.state.dropdown.suggestions = list;\n            return list.slice(0, suggestionsCount); // respect \"maxItems\" dropdown setting\n        }\n\n        niddle = _sd.caseSensitive\n            ? \"\"+value\n            : (\"\"+value).toLowerCase()\n\n        // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order\n        function stringHasAll(s, query){\n            return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()))\n        }\n\n        for( ; i < whitelist.length; i++ ){\n            let startsWithMatch, exactMatch;\n\n            whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : { value:whitelist[i] } //normalize value as an Object\n\n            let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k) ),\n                _searchKeys = itemWithoutSearchKeys ? [\"value\"] : searchKeys\n\n            if( _sd.fuzzySearch && !options.exact ){\n                searchBy = _searchKeys.reduce((values, k) => values + \" \" + (whitelistItem[k]||\"\"), \"\").toLowerCase().trim()\n\n                if( _sd.accentedSearch ){\n                    searchBy = unaccent(searchBy)\n                    niddle = unaccent(niddle)\n                }\n\n                startsWithMatch = searchBy.indexOf(niddle) == 0\n                exactMatch = searchBy === niddle\n                valueIsInWhitelist = stringHasAll(searchBy, niddle)\n            }\n\n            else {\n                startsWithMatch = true;\n                valueIsInWhitelist = _searchKeys.some(k => {\n                    var v = '' + (whitelistItem[k] || '') // if key exists, cast to type String\n\n                    if( _sd.accentedSearch ){\n                        v = unaccent(v)\n                        niddle = unaccent(niddle)\n                    }\n\n                    if( !_sd.caseSensitive )\n                        v = v.toLowerCase()\n\n                    exactMatch = v === niddle\n\n                    return options.exact\n                        ? v === niddle\n                        : v.indexOf(niddle) == 0\n                })\n            }\n\n            isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate( isObject(whitelistItem) ? whitelistItem.value : whitelistItem )\n\n            // match for the value within each \"whitelist\" item\n            if( valueIsInWhitelist && !isDuplicate )\n                if( exactMatch && startsWithMatch)\n                    exactMatchesList.push(whitelistItem)\n                else if( _sd.sortby == 'startsWith' && startsWithMatch )\n                    list.unshift(whitelistItem)\n                else\n                    list.push(whitelistItem)\n        }\n\n        this.state.dropdown.suggestions = exactMatchesList.concat(list);\n\n        // custom sorting function\n        return typeof _sd.sortby == 'function'\n            ? _sd.sortby(exactMatchesList.concat(list), niddle)\n            : exactMatchesList.concat(list).slice(0, suggestionsCount)\n    },\n\n    /**\n     * Returns the final value of a tag data (object) with regards to the \"mapValueTo\" dropdown setting\n     * @param {Object} tagData\n     * @returns\n     */\n    getMappedValue(tagData){\n        var mapValueTo = this.settings.dropdown.mapValueTo,\n            value = (mapValueTo\n                ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : (tagData[mapValueTo] || tagData.value)\n                : tagData.value);\n\n        return value\n    },\n\n    /**\n     * Creates the dropdown items' HTML\n     * @param  {Array} sugegstionsList  [Array of Objects]\n     * @return {String}\n     */\n    createListHTML( sugegstionsList ){\n        return extend([], sugegstionsList).map((suggestion, idx) => {\n            if( typeof suggestion == 'string' || typeof suggestion == 'number' )\n                suggestion = {value:suggestion}\n\n            var mappedValue = this.dropdown.getMappedValue(suggestion);\n\n            mappedValue = (typeof mappedValue == 'string' && this.settings.dropdown.escapeHTML)\n                ? escapeHTML(mappedValue)\n                : mappedValue;\n\n            return this.settings.templates.dropdownItem.apply(this, [{...suggestion, mappedValue}, this])\n        }).join(\"\")\n    }\n}", "const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.\r\nconst STORE_KEY = '@yaireo/tagify/'\r\n\r\nexport const getPersistedData = id => key => {\r\n    // if \"persist\" is \"false\", do not save to localstorage\r\n    let customKey = '/'+key,\r\n        persistedData,\r\n        versionMatch = localStorage.getItem(STORE_KEY + id + '/v', VERSION) == VERSION\r\n\r\n    if( versionMatch ){\r\n        try{ persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]) }\r\n        catch(err){}\r\n    }\r\n\r\n    return persistedData\r\n}\r\n\r\nexport const setPersistedData = id => {\r\n    if( !id ) return () => {};\r\n\r\n    // for storage invalidation\r\n    localStorage.setItem(STORE_KEY + id + '/v', VERSION)\r\n\r\n    return (data, key) => {\r\n        let customKey = '/'+key,\r\n            persistedData = JSON.stringify(data)\r\n\r\n        if( data && key ){\r\n            localStorage.setItem(STORE_KEY + id + customKey, persistedData)\r\n            dispatchEvent( new Event('storage') )\r\n        }\r\n    }\r\n}\r\n\r\nexport const clearPersistedData = id => key => {\r\n    const base = STORE_KEY + '/' + id + '/';\r\n\r\n    // delete specific key in the storage\r\n    if( key )\r\n        localStorage.removeItem(base + key)\r\n\r\n    // delete all keys in the storage with a specific tagify id\r\n    else {\r\n        for(let k in localStorage)\r\n            if( k.includes(base) )\r\n                localStorage.removeItem(k)\r\n    }\r\n}\r\n", "export default {\r\n    empty      : \"empty\",\r\n    exceed     : \"number of tags exceeded\",\r\n    pattern    : \"pattern mismatch\",\r\n    duplicate  : \"already exists\",\r\n    notAllowed : \"not allowed\"\r\n}", "import {ZERO_WIDTH_UNICODE_CHAR} from './constants'\r\n\r\nexport default {\r\n    /**\r\n     *\r\n     * @param {DOM Object} input     Original input DOm element\r\n     * @param {Object}     settings  Tagify instance settings Object\r\n     */\r\n    wrapper(input, _s){\r\n        return `<tags class=\"${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + \"Mode\"]}` : \"\"} ${input.className}\"\r\n                    ${_s.readonly ? 'readonly' : ''}\r\n                    ${_s.disabled ? 'disabled' : ''}\r\n                    ${_s.required ? 'required' : ''}\r\n                    ${_s.mode === 'select' ? \"spellcheck='false'\" : ''}\r\n                    tabIndex=\"-1\">\r\n                    ${this.settings.templates.input.call(this)}\r\n                ${ZERO_WIDTH_UNICODE_CHAR}\r\n        </tags>`\r\n    },\r\n\r\n    input() {\r\n        var _s = this.settings,\r\n            placeholder = _s.placeholder || ZERO_WIDTH_UNICODE_CHAR;\r\n\r\n        return `<span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} tabIndex=\"0\" data-placeholder=\"${placeholder}\" aria-placeholder=\"${_s.placeholder || ''}\"\r\n                    class=\"${_s.classNames.input}\"\r\n                    role=\"textbox\"\r\n                    autocapitalize=\"false\"\r\n                    autocorrect=\"off\"\r\n                    spellcheck=\"false\"\r\n                    aria-autocomplete=\"both\"\r\n                    aria-multiline=\"${_s.mode=='mix'?true:false}\"></span>`\r\n    },\r\n\r\n    tag(tagData, {settings: _s}){\r\n        return `<tag title=\"${(tagData.title || tagData.value)}\"\r\n                    contenteditable='false'\r\n                    tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\"\r\n                    class=\"${_s.classNames.tag} ${tagData.class || \"\"}\"\r\n                    ${this.getAttributes(tagData)}>\r\n            <x title='' tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\" class=\"${_s.classNames.tagX}\" role='button' aria-label='remove tag'></x>\r\n            <div>\r\n                <span ${_s.mode === 'select' && _s.userInput ? \"contenteditable='true'\" : ''} autocapitalize=\"false\" autocorrect=\"off\" spellcheck='false' class=\"${_s.classNames.tagText}\">${tagData[_s.tagTextProp] || tagData.value}</span>\r\n            </div>\r\n        </tag>`\r\n    },\r\n\r\n    dropdown(settings){\r\n        var _sd = settings.dropdown,\r\n            isManual = _sd.position == 'manual';\r\n\r\n        return `<div class=\"${isManual ? '' : settings.classNames.dropdown } ${_sd.classname}\" role=\"listbox\" aria-labelledby=\"dropdown\" dir=\"${_sd.RTL ? 'rtl' : ''}\">\r\n                    <div data-selector='tagify-suggestions-wrapper' class=\"${settings.classNames.dropdownWrapper}\"></div>\r\n                </div>`\r\n    },\r\n\r\n    dropdownContent(HTMLContent) {\r\n        var _t = this.settings.templates,\r\n            suggestions = this.state.dropdown.suggestions;\r\n\r\n        return `\r\n            ${_t.dropdownHeader.call(this, suggestions)}\r\n            ${HTMLContent}\r\n            ${_t.dropdownFooter.call(this, suggestions)}\r\n        `\r\n    },\r\n\r\n    dropdownItem(item){\r\n        return `<div ${this.getAttributes(item)}\r\n                    class='${this.settings.classNames.dropdownItem} ${this.isTagDuplicate(item.value) ? this.settings.classNames.dropdownItemSelected: \"\"} ${item.class || \"\"}'\r\n                    tabindex=\"0\"\r\n                    role=\"option\">${item.mappedValue || item.value}</div>`\r\n    },\r\n\r\n    /**\r\n     * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the \"dropdown.maxItems\" setting\r\n     */\r\n    dropdownHeader(suggestions){\r\n        return `<header data-selector='tagify-suggestions-header' class=\"${this.settings.classNames.dropdownHeader}\"></header>`\r\n    },\r\n\r\n    dropdownFooter(suggestions){\r\n        var hasMore = suggestions.length - this.settings.dropdown.maxItems;\r\n\r\n        return hasMore > 0\r\n            ? `<footer data-selector='tagify-suggestions-footer' class=\"${this.settings.classNames.dropdownFooter}\">\r\n                ${hasMore} more items. Refine your search.\r\n            </footer>`\r\n            : '';\r\n    },\r\n\r\n    dropdownItemNoMatch: null\r\n}\r\n", "import { decode, extend, getfirstTextNode, isChromeAndroidBrowser, isNodeTag, isWithinNodeTag, injectAtCaret, getSetTagData, fixCaretBetweenTags, placeCaretAfterNode } from './helpers'\nimport {ZERO_WIDTH_CHAR} from './constants'\n\nexport function triggerChangeEvent(){\n    if( this.settings.mixMode.integrated ) return;\n\n    var inputElm = this.DOM.originalInput,\n        changed = this.state.lastOriginalValueReported !== inputElm.value,\n        event = new CustomEvent(\"change\", {bubbles: true}); // must use \"CustomEvent\" and not \"Event\" to support IE\n\n    if( !changed ) return;\n\n    // must apply this BEFORE triggering the simulated event\n    this.state.lastOriginalValueReported = inputElm.value\n\n    // React hack: https://github.com/facebook/react/issues/11488\n    event.simulated = true\n    if (inputElm._valueTracker)\n        inputElm._valueTracker.setValue(Math.random())\n\n    inputElm.dispatchEvent(event)\n\n    // also trigger a Tagify event\n    this.trigger(\"change\", this.state.lastOriginalValueReported)\n\n    // React, for some reason, clears the input's value after \"dispatchEvent\" is fired\n    inputElm.value = this.state.lastOriginalValueReported\n}\n\nexport default {\n    // bind custom events which were passed in the settings\n    customBinding(){\n        this.customEventsList.forEach(name => {\n            this.on(name, this.settings.callbacks[name])\n        })\n    },\n\n    binding( bindUnbind = true ){\n        var _s = this.settings,\n            _CB = this.events.callbacks,\n            _CBR,\n            action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n        // do not allow the main events to be bound more than once\n        if( this.state.mainEvents && bindUnbind )\n            return;\n\n        // set the binding state of the main events, so they will not be bound more than once\n        this.state.mainEvents = bindUnbind;\n\n        // everything inside gets executed only once-per instance\n        if( bindUnbind && !this.listeners.main ){\n            this.events.bindGlobal.call(this);\n\n            if( this.settings.isJQueryPlugin )\n                jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this))\n        }\n\n\n        // TODO: bind bubblable \"focusin\" and \"focusout\" events on the Tagify scope itself and not the input\n\n\n        // setup callback references so events could be removed later\n        _CBR = (this.listeners.main = this.listeners.main || {\n            keydown          : ['input', _CB.onKeydown.bind(this)],\n            click            : ['scope', _CB.onClickScope.bind(this)],\n            dblclick         : _s.mode != 'select' && ['scope', _CB.onDoubleClickScope.bind(this)],\n            paste            : ['input', _CB.onPaste.bind(this)],\n            drop             : ['input', _CB.onDrop.bind(this)],\n            compositionstart : ['input', _CB.onCompositionStart.bind(this)],\n            compositionend   : ['input', _CB.onCompositionEnd.bind(this)]\n        })\n\n        for( var eventName in _CBR ){\n            _CBR[eventName] && this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);\n        }\n\n        // observers\n        var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this));\n\n        // cleaup just-in-case\n        inputMutationObserver.disconnect()\n\n        // observe stuff\n        if( _s.mode == 'mix' ) {\n            inputMutationObserver.observe(this.DOM.input, {childList:true})\n        }\n\n        this.events.bindOriginaInputListener.call(this)\n    },\n\n    bindOriginaInputListener(delay) {\n        const DELAY = (delay||0) + 500\n\n        if(!this.listeners.main) return\n        // listen to original input changes (unfortunetly this is the best way...)\n        // https://stackoverflow.com/a/1949416/104380\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\n        this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), DELAY)\n    },\n\n    bindGlobal( unbind ) {\n        var _CB = this.events.callbacks,\n            action = unbind ? 'removeEventListener' : 'addEventListener',\n            e;\n\n        if( !this.listeners || (!unbind  && this.listeners.global) ) return; // do not re-bind\n\n        // these events are global and should never be unbinded, unless the instance is destroyed:\n        this.listeners.global = this.listeners.global || [\n            {\n                type: this.isIE ? 'keydown' : 'input',  // IE cannot register \"input\" events on contenteditable elements, so the \"keydown\" should be used instead..\n                target: this.DOM.input,\n                cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)\n            },\n            {\n                type: 'keydown',\n                target: window,\n                cb: _CB.onWindowKeyDown.bind(this)\n            },\n            {\n                type: 'focusin',\n                target: this.DOM.scope,\n                cb: _CB.onFocusBlur.bind(this)\n            },\n            {\n                type: 'focusout',\n                target: this.DOM.scope,\n                cb: _CB.onFocusBlur.bind(this)\n            },\n            {\n                type: 'click',\n                target: document,\n                cb: _CB.onClickAnywhere.bind(this),\n                useCapture: true\n            },\n        ]\n\n        for( e of this.listeners.global )\n            e.target[action](e.type, e.cb, !!e.useCapture);\n    },\n\n    unbindGlobal() {\n        this.events.bindGlobal.call(this, true);\n    },\n\n    /**\n     * DOM events callbacks\n     */\n    callbacks : {\n        onFocusBlur(e){\n            // when focusing within a tag which is in edit-mode\n            var _s = this.settings,\n                nodeTag = isWithinNodeTag.call(this, e.target),\n                targetIsTagNode = isNodeTag.call(this, e.target),\n                isTargetXBtn = e.target.classList.contains(_s.classNames.tagX),\n                isFocused = e.type == 'focusin',\n                lostFocus = e.type == 'focusout';\n\n            // when focusing within a tag which is in edit-mode, only and specifically on the text-part of the tag node\n            // and not the X button or any other custom element thatmight be there\n            // var tagTextNode = e.target?.closest(this.settings.classNames.tagTextSelector)\n\n            if( nodeTag && isFocused && (!targetIsTagNode) && !isTargetXBtn) {\n                this.toggleFocusClass(this.state.hasFocus = +new Date())\n\n                // only if focused within a tag's text node should the `onEditTagFocus` function be called.\n                // if clicked anywhere else inside a tag, which had triggered an `focusin` event,\n                // the onFocusBlur should be aborted. This part was spcifically written for `select` mode.\n                // tagTextNode && this.events.callbacks.onEditTagFocus.call(this, nodeTag)\n            }\n\n            var text = e.target ? this.trim(this.DOM.input.textContent) : '', // a string\n                currentDisplayValue = this.value?.[0]?.[_s.tagTextProp],\n                ddEnabled = _s.dropdown.enabled >= 0,\n                eventData = {relatedTarget:e.relatedTarget},\n                isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),\n                isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,\n                shouldAddTags;\n\n            if( lostFocus ){\n                if( e.relatedTarget === this.DOM.scope ){\n                    this.dropdown.hide()\n                    this.DOM.input.focus()\n                    return\n                }\n\n                this.postUpdate()\n                _s.onChangeAfterBlur && this.triggerChangeEvent()\n            }\n\n            if( isTargetSelectOption || isTargetAddNewBtn || isTargetXBtn )\n                return;\n\n            // should only loose focus at this point if the event was not generated from within a tag, within the component\n            if( isFocused || nodeTag ) {\n                this.state.hasFocus = +new Date()\n                this.toggleFocusClass(this.state.hasFocus)\n            }\n            else {\n                this.state.hasFocus = false;\n            }\n\n            if( _s.mode == 'mix' ){\n                if( isFocused ){\n                    this.trigger(\"focus\", eventData)\n                }\n\n                else if( lostFocus ){\n                    this.trigger(\"blur\", eventData)\n                    this.loading(false)\n                    this.dropdown.hide()\n                    // reset state which needs reseting\n                    this.state.dropdown.visible = undefined\n                    this.setStateSelection()\n                }\n\n                return\n            }\n\n            if( isFocused ){\n                if( !_s.focusable ) return;\n\n                var dropdownCanBeShown = _s.dropdown.enabled === 0 && !this.state.dropdown.visible,\n                    condition2 = !targetIsTagNode || _s.mode === 'select'\n\n                this.toggleFocusClass(true);\n                this.trigger(\"focus\", eventData)\n                //  e.target.classList.remove('placeholder');\n                if( dropdownCanBeShown && condition2 ){  // && _s.mode != \"select\"\n                    this.dropdown.show(this.value.length ? '' : undefined)\n                }\n\n                return\n            }\n\n            else if( lostFocus ){\n                this.trigger(\"blur\", eventData)\n                this.loading(false)\n\n                // when clicking the X button of a selected tag, it is unwanted for it to be added back\n                // again in a few more lines of code (shouldAddTags && addTags)\n                if( _s.mode == 'select' ) {\n                    if( this.value.length ) {\n                        let firstTagNode = this.getTagElms()[0];\n                        text = this.trim(firstTagNode.textContent)\n                    }\n\n                    // if nothing has changed (same display value), do not add a tag\n                    if( currentDisplayValue === text )\n                        text = ''\n                }\n\n                shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur && _s.addTagOn.includes('blur');\n\n                // do not add a tag if \"selectOption\" action was just fired (this means a tag was just added from the dropdown)\n                shouldAddTags && this.addTags(text, true)\n            }\n\n            // when clicking a tag, do not consider this is a \"blur\" event\n            if ( !nodeTag )  {\n                this.DOM.input.removeAttribute('style')\n                this.dropdown.hide()\n            }\n        },\n\n        onCompositionStart(e){\n            this.state.composing = true\n        },\n\n        onCompositionEnd(e){\n            this.state.composing = false\n        },\n\n        onWindowKeyDown(e){\n            var _s = this.settings,\n                focusedElm = document.activeElement,\n                withinTag = isWithinNodeTag.call(this, focusedElm),\n                isBelong = withinTag && this.DOM.scope.contains(document.activeElement),\n                isReadyOnlyTag = isBelong && focusedElm.hasAttribute('readonly'),\n                nextTag;\n\n            if( !this.state.hasFocus && (!isBelong || isReadyOnlyTag) ) return;\n\n            nextTag = focusedElm.nextElementSibling;\n\n            var targetIsRemoveBtn = e.target.classList.contains(_s.classNames.tagX);\n\n            switch( e.key ){\n                // remove tag if has focus\n                case 'Backspace': {\n                    if( !_s.readonly && !this.state.editing ) {\n                        this.removeTags(focusedElm);\n                        (nextTag ? nextTag : this.DOM.input).focus()\n                    }\n\n                    break;\n                }\n\n                case 'Enter': {\n                    if( targetIsRemoveBtn ) {\n                        this.removeTags( e.target.parentNode )\n                        return\n                    }\n\n                    if( _s.a11y.focusableTags && isNodeTag.call(this, focusedElm) )\n                        setTimeout(this.editTag.bind(this), 0, focusedElm)\n\n                    break;\n                }\n\n                case 'ArrowDown' : {\n                    // if( _s.mode == 'select' ) // issue #333\n                    if( !this.state.dropdown.visible && _s.mode != 'mix' )\n                        this.dropdown.show()\n                    break;\n                }\n            }\n        },\n\n        onKeydown(e){\n            var _s = this.settings;\n\n            // ignore keys during IME composition or when user input is not allowed\n            if( this.state.composing || !_s.userInput )\n                return\n\n            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab' ){\n                e.preventDefault()\n            }\n\n            var s = this.trim(e.target.textContent);\n\n            this.trigger(\"keydown\", {event:e})\n\n            _s.hooks.beforeKeyDown(e, {tagify:this})\n                .then(result => {\n                    /**\n                     * ONLY FOR MIX-MODE:\n                     */\n                    if( _s.mode == 'mix' ){\n                        switch( e.key ){\n                            case 'Left' :\n                            case 'ArrowLeft' : {\n                                // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored\n                                // because it seems likely the user wishes to use the arrows to move the caret\n                                this.state.actions.ArrowLeft = true\n                                break\n                            }\n\n                            case 'Delete':\n                            case 'Backspace' : {\n                                if( this.state.editing ) return\n\n                                var sel = document.getSelection(),\n                                    deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),\n                                    prevAnchorSibling = sel.anchorNode.previousSibling,\n                                    isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling,\n                                    lastInputValue = decode(this.DOM.input.innerHTML),\n                                    lastTagElems = this.getTagElms(),\n                                    isZWS = sel.anchorNode.length === 1 && sel.anchorNode.nodeValue == String.fromCharCode(8203),\n                                    //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),\n                                    tagBeforeCaret,\n                                    tagElmToBeDeleted,\n                                    firstTextNodeBeforeTag;\n\n                                if( _s.backspace == 'edit' && isCaretAfterTag ){\n                                    tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;\n                                    setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted\n                                    e.preventDefault() // needed so the tag elm won't get deleted\n                                    return;\n                                }\n\n                                if( isChromeAndroidBrowser() && isCaretAfterTag instanceof Element ){\n                                    firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag)\n\n                                    if( !isCaretAfterTag.hasAttribute('readonly') )\n                                        isCaretAfterTag.remove() // since this is Chrome, can safetly use this \"new\" DOM API\n\n                                    // Android-Chrome wrongly hides the keyboard, and loses focus,\n                                    // so this hack below is needed to regain focus at the correct place:\n                                    this.DOM.input.focus()\n                                    setTimeout(() => {\n                                        placeCaretAfterNode(firstTextNodeBeforeTag)\n                                        this.DOM.input.click()\n\n                                    })\n\n                                    return\n                                }\n\n                                if( sel.anchorNode.nodeName == 'BR')\n                                    return\n\n                                if( (deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1 )\n                                    if( sel.anchorOffset == 0 ) // caret is at the very begining, before a tag\n                                        tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed\n                                            ? lastTagElems[0]\n                                            : null;\n                                    else\n                                        tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1]\n\n                                // find out if a tag *might* be a candidate for deletion, and if so, which\n                                else if( deleteKeyTagDetected )\n                                    tagElmToBeDeleted = sel.anchorNode.nextElementSibling;\n\n                                else if( isCaretAfterTag instanceof Element )\n                                    tagElmToBeDeleted = isCaretAfterTag;\n\n                                // tagElm.hasAttribute('readonly')\n                                if( sel.anchorNode.nodeType == 3 &&   // node at caret location is a Text node\n                                    !sel.anchorNode.nodeValue    &&   // has some text\n                                    sel.anchorNode.previousElementSibling )  // text node has a Tag node before it\n                                    e.preventDefault()\n\n                                // if backspace not allowed, do nothing\n                                // TODO: a better way to detect if nodes were deleted is to simply check the \"this.value\" before & after\n                                if( (isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace ){\n                                    e.preventDefault()\n                                    return\n                                }\n\n                                if( sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete' ){\n                                    e.preventDefault()\n                                    return\n                                }\n\n                                if( sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly') ){\n                                    // allows the continuation of deletion by placing the caret on the first previous textNode.\n                                    // since a few readonly-tags might be one after the other, iteration is needed:\n\n                                    placeCaretAfterNode( getfirstTextNode(tagElmToBeDeleted) )\n                                    return\n                                }\n\n                                if ( e.key == 'Delete' && isZWS && getSetTagData(sel.anchorNode.nextSibling) ) {\n                                    this.removeTags(sel.anchorNode.nextSibling)\n                                }\n\n                                // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:\n                                // the bug described is more severe than the fix below, therefore I disable the fix until a solution\n                                // is found which work well for both cases.\n                                // -------\n                                // nodeType is \"1\" only when the caret is at the end after last tag (no text after), or before first first (no text before)\n                                /*\n                                if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){\n                                    this.removeTags() // removes last tag by default if no parameter supplied\n                                    // place caret inside last textNode, if exist. it's an annoying bug only in FF,\n                                    // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end\n                                    placeCaretAfterNode( setRangeAtStartEnd(false, this.DOM.input) )\n                                }\n                                */\n\n                                break;\n                            }\n                            // currently commented to allow new lines in mixed-mode\n                            // case 'Enter' :\n                            //     // e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n                        }\n\n                        return true\n                    }\n\n                    var isManualDropdown = _s.dropdown.position == 'manual';\n\n                    switch( e.key ){\n                        case 'Backspace' :\n                            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length)\n                                this.removeTags()\n\n                            else if( !this.state.dropdown.visible || _s.dropdown.position == 'manual' ){\n                                if( e.target.textContent == \"\" || s.charCodeAt(0) == 8203 ){  // 8203: ZERO WIDTH SPACE unicode\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0) // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)\n                                }\n                            }\n                            break;\n\n                        case 'Esc' :\n                        case 'Escape' :\n                            if( this.state.dropdown.visible ) return\n                            e.target.blur()\n                            break;\n\n                        case 'Down' :\n                        case 'ArrowDown' :\n                            // if( _s.mode == 'select' ) // issue #333\n                            if( !this.state.dropdown.visible )\n                                this.dropdown.show()\n                            break;\n\n                        case 'ArrowRight' : {\n                            let tagData = this.state.inputSuggestion || this.state.ddItemData\n                            if( tagData && _s.autoComplete.rightKey ){\n                                this.addTags([tagData], true)\n                                return;\n                            }\n                            break\n                        }\n                        case 'Tab' : {\n                            let selectMode = _s.mode == 'select'\n                            if(s && !selectMode) e.preventDefault()\n                            else return true;\n                        }\n\n                        case 'Enter' :\n                            // manual suggestion boxes are assumed to always be visible\n                            if( this.state.dropdown.visible && !isManualDropdown ) return\n                            e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n                            // because the main \"keydown\" event is bound before the dropdown events, this will fire first and will not *yet*\n                            // know if an option was just selected from the dropdown menu. If an option was selected,\n                            // the dropdown events should handle adding the tag\n\n                            setTimeout(()=>{\n                                if( (!this.state.dropdown.visible || isManualDropdown) && !this.state.actions.selectOption && _s.addTagOn.includes(e.key.toLowerCase()) )\n                                    this.addTags(s, true)\n                            })\n                    }\n                })\n                .catch(err => err)\n        },\n\n        onInput(e){\n            this.postUpdate() // toggles \"tagify--empty\" class\n\n            var _s = this.settings;\n\n            if( _s.mode == 'mix' )\n                return this.events.callbacks.onMixTagsInput.call(this, e);\n\n            var value = this.input.normalize.call(this, undefined, {trim: false}),\n                showSuggestions = value.length >= _s.dropdown.enabled,\n                eventData = {value, inputElm:this.DOM.input},\n                validation = this.validateTag({value});\n\n            if( _s.mode == 'select' ) {\n                this.toggleScopeValidation(validation)\n            }\n\n            eventData.isValid = validation;\n\n            // for IE; since IE doesn't have an \"input\" event so \"keyDown\" is used instead to trigger the \"onInput\" callback,\n            // and so many keys do not change the input, and for those do not continue.\n            if( this.state.inputText == value ) return;\n\n            // save the value on the input's State object\n            this.input.set.call(this, value, false); // update the input with the normalized value and run validations\n            // this.setRangeAtStartEnd(false, this.DOM.input); // fix caret position\n\n            // if delimiters detected, add tags\n            if( value.search(_s.delimiters) != -1 ){\n                if( this.addTags( value ) ){\n                    this.input.set.call(this); // clear the input field's value\n                }\n            }\n\n            else if( _s.dropdown.enabled >= 0 ){\n                this.dropdown[showSuggestions ? \"show\" : \"hide\"](value);\n            }\n\n            this.trigger('input', eventData) // \"input\" event must be triggered at this point, before the dropdown is shown\n        },\n\n        onMixTagsInput( e ){\n            var rangeText, match, matchedPatternCount, tag, showSuggestions, selection,\n                _s = this.settings,\n                lastTagsCount = this.value.length,\n                matchFlaggedTag,\n                matchDelimiters,\n                tagsElems = this.getTagElms(),\n                fragment = document.createDocumentFragment(),\n                range = window.getSelection().getRangeAt(0),\n                remainingTagsValues = [].map.call(tagsElems, node => getSetTagData(node).value);\n\n            // Android Chrome \"keydown\" event argument does not report the correct \"key\".\n            // this workaround is needed to manually call \"onKeydown\" method with a synthesized event object\n            if( e.inputType == \"deleteContentBackward\" && isChromeAndroidBrowser() ){\n                this.events.callbacks.onKeydown.call(this, {\n                    target: e.target,\n                    key: \"Backspace\",\n                })\n            }\n\n            // if there's a tag as the first child of the input, always make sure it has a zero-width character before it\n            // or if two tags are next to each-other, add a zero-space width character (For the caret to appear)\n            fixCaretBetweenTags(this.getTagElms())\n\n            // re-add \"readonly\" tags which might have been removed\n            this.value.slice().forEach(item => {\n                if( item.readonly && !remainingTagsValues.includes(item.value) )\n                    fragment.appendChild( this.createTagElem(item) )\n            })\n\n            if( fragment.childNodes.length ){\n                range.insertNode(fragment)\n                this.setRangeAtStartEnd(false, fragment.lastChild)\n            }\n\n            // check if tags were \"magically\" added/removed (browser redo/undo or CTRL-A -> delete)\n            if( tagsElems.length != lastTagsCount ){\n                this.value = [].map.call(this.getTagElms(), node => getSetTagData(node))\n                this.update({ withoutChangeEvent:true })\n                return\n            }\n\n            if( this.hasMaxTags() )\n                return true\n\n            if( window.getSelection ){\n                selection = window.getSelection()\n\n                // only detect tags if selection is inside a textNode (not somehow on already-existing tag)\n                if( selection.rangeCount > 0 && selection.anchorNode.nodeType == 3 ){\n                    range = selection.getRangeAt(0).cloneRange()\n                    range.collapse(true)\n                    range.setStart(selection.focusNode, 0)\n\n                    rangeText = range.toString().slice(0, range.endOffset)  // slice the range so everything AFTER the caret will be trimmed\n                    // split = range.toString().split(_s.mixTagsAllowedAfter)  // [\"foo\", \"bar\", \"@baz\"]\n                    matchedPatternCount = rangeText.split(_s.pattern).length - 1;\n\n                    match = rangeText.match( _s.pattern )\n\n                    if( match )\n                        // tag string, example: \"@aaa ccc\"\n                        tag = rangeText.slice( rangeText.lastIndexOf(match[match.length-1]) )\n\n                    if( tag ){\n                        this.state.actions.ArrowLeft = false // start fresh, assuming the user did not (yet) used any arrow to move the caret\n                        this.state.tag = {\n                            prefix : tag.match(_s.pattern)[0],\n                            value  : tag.replace(_s.pattern, ''), // get rid of the prefix\n                        }\n                        this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length\n\n                        matchDelimiters = this.state.tag.value.match(_s.delimiters)\n                        // if a delimeter exists, add the value as tag (exluding the delimiter)\n                        if( matchDelimiters ){\n                            this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '')\n                            this.state.tag.delimiters = matchDelimiters[0]\n                            this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect)\n                            this.dropdown.hide()\n                            return\n                        }\n\n                        showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled\n\n                        // When writing something that might look like a tag (an email address) but isn't one - it is unwanted\n                        // the suggestions dropdown be shown, so the user can close it (in any way), and while continue typing,\n                        // dropdown should stay closed until another tag is typed.\n                        // if( this.state.tag.value.length && this.state.dropdown.visible === false )\n                        //     showSuggestions = false\n\n                        // test for similar flagged tags to the current tag\n\n                        try{\n                            matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset]\n                            matchFlaggedTag = matchFlaggedTag.prefix   == this.state.tag.prefix &&\n                                              matchFlaggedTag.value[0] == this.state.tag.value[0]\n\n                            // reset\n                            if( this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value )\n                                delete this.state.flaggedTags[this.state.tag.baseOffset];\n                        }\n                        catch(err){}\n\n                        // scenario: (do not show suggestions of another matched tag, if more than one detected)\n                        // (2 tags exist)                          \" a@a.com and @\"\n                        // (second tag is removed by backspace)    \" a@a.com and \"\n                        if( matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount )\n                            showSuggestions = false\n                    }\n                    // no (potential) tag found\n                    else{\n                        this.state.flaggedTags = {}\n                    }\n\n                    this.state.mixMode.matchedPatternCount = matchedPatternCount\n                }\n            }\n\n\n            // wait until the \"this.value\" has been updated (see \"onKeydown\" method for \"mix-mode\")\n            // the dropdown must be shown only after this event has been triggered, so an implementer could\n            // dynamically change the whitelist.\n            setTimeout(()=>{\n                this.update({withoutChangeEvent:true})\n                this.trigger('input', extend({}, this.state.tag, {textContent:this.DOM.input.textContent}))\n\n                if( this.state.tag )\n                    this.dropdown[showSuggestions ? \"show\" : \"hide\"](this.state.tag.value);\n            }, 10)\n        },\n\n        onInputIE(e){\n            var _this = this;\n            // for the \"e.target.textContent\" to be changed, the browser requires a small delay\n            setTimeout(function(){\n                _this.events.callbacks.onInput.call(_this, e)\n            })\n        },\n\n        observeOriginalInputValue(){\n            // if, for some reason, the Tagified element is no longer in the DOM,\n            // call the \"destroy\" method to kill all references to timeouts/intervals\n            if( !this.DOM.originalInput.parentNode ) this.destroy()\n\n            // if original input value changed for some reason (for exmaple a form reset)\n            if( this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue )\n                this.loadOriginalValues()\n        },\n\n        onClickAnywhere(e){\n            if (e.target != this.DOM.scope && !this.DOM.scope.contains(e.target)) {\n                this.toggleFocusClass(false)\n                this.state.hasFocus = false\n\n                // do not hide the dropdown if a click was initiated within it and that dropdown belongs to this Tagify instance\n                if( e.target.closest('.tagify__dropdown') && e.target.closest('.tagify__dropdown').__tagify != this )\n                    this.dropdown.hide()\n            }\n        },\n\n        onClickScope(e){\n            var _s = this.settings,\n                tagElm = e.target.closest('.' + _s.classNames.tag),\n                isScope = e.target === this.DOM.scope,\n                timeDiffFocus = +new Date() - this.state.hasFocus;\n\n            if( isScope && _s.mode != 'select' ){\n                // if( !this.state.hasFocus )\n                    this.DOM.input.focus()\n                return\n            }\n\n            else if( e.target.classList.contains(_s.classNames.tagX) ){\n                this.removeTags( e.target.parentNode )\n                return\n            }\n\n            else if( tagElm && !this.state.editing ){\n                this.trigger(\"click\", { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm), event:e })\n\n                if( _s.editTags === 1 || _s.editTags.clicks === 1 || _s.mode == 'select' )\n                    this.events.callbacks.onDoubleClickScope.call(this, e)\n\n                return\n            }\n\n            // when clicking on the input itself\n            else if( e.target == this.DOM.input ){\n                if( _s.mode == 'mix' ){\n                    // firefox won't show caret if last element is a tag (and not a textNode),\n                    // so an empty textnode should be added\n                    this.fixFirefoxLastTagNoCaret()\n                }\n\n                if( timeDiffFocus > 500 || !_s.focusable ){\n                    if( this.state.dropdown.visible )\n                        this.dropdown.hide()\n                    else if( _s.dropdown.enabled === 0 && _s.mode != 'mix' )\n                        this.dropdown.show(this.value.length ? '' : undefined)\n                    return\n                }\n            }\n\n            if( _s.mode == 'select' && _s.dropdown.enabled === 0 && !this.state.dropdown.visible) {\n                this.events.callbacks.onDoubleClickScope.call(this, {...e, target: this.getTagElms()[0]})\n\n                !_s.userInput && this.dropdown.show()\n            }\n        },\n\n        // special proccess is needed for pasted content in order to \"clean\" it\n        onPaste(e){\n            e.preventDefault()\n\n            var tagsElems,\n                _s = this.settings,\n                selectModeWithoutInput =_s.mode == 'select' && _s.enforceWhitelist;\n\n            if( selectModeWithoutInput || !_s.userInput ){\n                return false;\n            }\n\n            var clipboardData, pastedText;\n\n            if( _s.readonly ) return\n\n            // Get pasted data via clipboard API\n            clipboardData = e.clipboardData || window.clipboardData\n            pastedText = clipboardData.getData('Text')\n\n            _s.hooks.beforePaste(e, {tagify:this, pastedText, clipboardData})\n                .then(result => {\n                    if( result === undefined )\n                        result = pastedText;\n\n                    if( result ){\n                        this.injectAtCaret(result, window.getSelection().getRangeAt(0))\n\n                        if( this.settings.mode == 'mix' ){\n                            this.events.callbacks.onMixTagsInput.call(this, e);\n                        }\n\n                        else if( this.settings.pasteAsTags ){\n                            tagsElems = this.addTags(this.state.inputText + result, true)\n                        }\n\n                        else {\n                            this.state.inputText = result\n                            this.dropdown.show(result)\n                        }\n                    }\n\n                    this.trigger('paste', {event: e, pastedText, clipboardData, tagsElems})\n                })\n                .catch(err => err)\n        },\n\n        onDrop(e){\n            e.preventDefault()\n        },\n\n        onEditTagInput( editableElm, e ){\n            var tagElm = editableElm.closest('.' + this.settings.classNames.tag),\n                tagElmIdx = this.getNodeIndex(tagElm),\n                tagData = getSetTagData(tagElm),\n                textValue = this.input.normalize.call(this, editableElm),\n                dataForChangedProp = {[this.settings.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                isValid = this.validateTag(dataForChangedProp), // the value could have been invalid in the first-place so make sure to re-validate it (via \"addEmptyTag\" method)\n                hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp));\n\n            // if the value is same as before-editing and the tag was valid before as well, ignore the  current \"isValid\" result, which is false-positive\n            if( !hasChanged && editableElm.originalIsValid === true )\n                isValid = true\n\n            tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true)\n            tagData.__isValid = isValid\n\n            tagElm.title = isValid === true\n                ? tagData.title || tagData.value\n                : isValid // change the tag's title to indicate why is the tag invalid (if it's so)\n\n            // show dropdown if typed text is equal or more than the \"enabled\" dropdown setting\n            if( textValue.length >= this.settings.dropdown.enabled ){\n                // this check is needed apparently because doing browser \"undo\" will fire\n                //  \"onEditTagInput\" but \"this.state.editing\" will be \"false\"\n                if( this.state.editing )\n                    this.state.editing.value = textValue\n                this.dropdown.show(textValue)\n            }\n\n            this.trigger(\"edit:input\", {\n                tag  : tagElm,\n                index: tagElmIdx,\n                data : extend({}, this.value[tagElmIdx], {newValue:textValue}),\n                event: e\n            })\n        },\n\n        onEditTagPaste( tagElm, e ){\n            // Get pasted data via clipboard API\n            var clipboardData = e.clipboardData || window.clipboardData,\n                pastedText = clipboardData.getData('Text');\n\n            e.preventDefault()\n\n            var newNode = injectAtCaret(pastedText)\n            this.setRangeAtStartEnd(false, newNode)\n        },\n\n        onEditTagClick( tagElm, e) {\n            this.events.callbacks.onClickScope.call(this, e)\n        },\n\n        onEditTagFocus( tagElm ){\n            this.state.editing = {\n                scope: tagElm,\n                input: tagElm.querySelector(\"[contenteditable]\")\n            }\n        },\n\n        onEditTagBlur( editableElm, e ){\n            // if \"relatedTarget\" is the tag then do not continue as this should not be considered a \"blur\" event\n            var isRelatedTargetNodeTag = isNodeTag.call(this, e.relatedTarget)\n\n            // in \"select-mode\" when editing the tag's template to include more nodes other than the editable \"span\",\n            // clicking those elements should not be considered a blur event\n            if( this.settings.mode == 'select' && isRelatedTargetNodeTag && e.relatedTarget.contains(e.target) ) {\n                this.dropdown.hide()\n                return\n            }\n\n            // if \"ESC\" key was pressed then the \"editing\" state should be `false` and if so, logic should not continue\n            // because \"ESC\" reverts the edited tag back to how it was (replace the node) before editing\n            if( !this.state.editing )\n                return;\n\n            if( !this.state.hasFocus )\n                this.toggleFocusClass()\n\n            // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it\n            // the \"onEditTagDone\" is called directly, already replacing the tag, so the argument \"editableElm\"\n            // node isn't in the DOM anynmore because it has been replaced.\n            if( !this.DOM.scope.contains(editableElm) ) return;\n\n            var _s           = this.settings,\n                tagElm       = editableElm.closest('.' + _s.classNames.tag),\n                tagData      = getSetTagData(tagElm),\n                textValue    = this.input.normalize.call(this, editableElm),\n                dataForChangedProp = {[_s.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                originalData = tagData.__originalData, // pre-edit data\n                hasChanged   = this.editTagChangeDetected(extend(tagData, dataForChangedProp)),\n                isValid      = this.validateTag(dataForChangedProp), // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                hasMaxTags,\n                newTagData;\n\n            if( !textValue ){\n                this.onEditTagDone(tagElm)\n                return\n            }\n\n            // if nothing changed revert back to how it was before editing\n            if( !hasChanged ){\n                this.onEditTagDone(tagElm, originalData)\n                return\n            }\n\n            // need to know this because if \"keepInvalidTags\" setting is \"true\" and an invalid tag is edited as a valid one,\n            // but the maximum number of tags have alreay been reached, so it should not allow saving the new valid value.\n            // only if the tag was already valid before editing, ignore this check (see a few lines below)\n            hasMaxTags = this.hasMaxTags()\n\n            newTagData = extend(\n                {},\n                originalData,\n                {\n                    [_s.tagTextProp]: this.trim(textValue),\n                    __isValid: isValid\n                }\n            )\n\n            // pass through optional transformer defined in settings\n            _s.transformTag.call(this, newTagData, originalData)\n\n            // MUST re-validate after tag transformation\n            // only validate the \"tagTextProp\" because is the only thing that metters for validating an edited tag.\n            // -- Scenarios: --\n            // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as \"not allowed\" because limit of tags has reached\n            // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK\n            isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData)\n\n            if( isValid !== true ){\n                this.trigger(\"invalid\", { data:newTagData, tag:tagElm, message:isValid })\n\n                // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc\n                if( _s.editTags.keepInvalid ) return\n\n                if( _s.keepInvalidTags )\n                    newTagData.__isValid = isValid\n                else\n                    // revert back if not specified to keep\n                    newTagData = originalData\n            }\n\n            else if( _s.keepInvalidTags ){\n                // cleaup any previous leftovers if the tag was invalid\n                delete newTagData.title\n                delete newTagData[\"aria-invalid\"]\n                delete newTagData.class\n            }\n\n            // tagElm.classList.toggle(_s.classNames.tagInvalid, true)\n\n            this.onEditTagDone(tagElm, newTagData)\n        },\n\n        onEditTagkeydown(e, tagElm){\n            // ignore keys during IME composition\n            if( this.state.composing )\n                return\n\n            this.trigger(\"edit:keydown\", {event:e})\n\n            switch( e.key ){\n                case 'Esc' :\n                case 'Escape' : {\n                    this.state.editing = false\n                    var hasValueToRevertTo = !!tagElm.__tagifyTagData.__originalData.value\n\n                    if( hasValueToRevertTo )\n                        // revert the tag to how it was before editing\n                        // replace current tag with original one (pre-edited one)\n                        tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm)\n                    else\n                        tagElm.remove()\n\n                    break\n                }\n                case 'Enter' :\n                case 'Tab' : {\n                    e.preventDefault()\n\n                    var EDITED_TAG_BLUR_DELAY = 0;\n\n                    // a setTimeout is used so when editing (in \"select\" mode) while the dropdown is shown and a suggestion is highlighted\n                    // and ENTER key is pressed down - the `dropdown.hide` method won't be invoked immediately and unbind the dropdown's\n                    // KEYDOWN \"ENTER\" before it has time to call the handler and select the suggestion.\n                    setTimeout(() => e.target.blur(), EDITED_TAG_BLUR_DELAY)\n                }\n            }\n        },\n\n        onDoubleClickScope(e){\n            var tagElm = e.target.closest('.' + this.settings.classNames.tag),\n                tagData = getSetTagData(tagElm),\n                _s = this.settings,\n                isEditingTag,\n                isReadyOnlyTag;\n\n            if( !tagElm || tagData.editable === false ) return\n\n            isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing)\n            isReadyOnlyTag = tagElm.hasAttribute('readonly')\n\n            if( !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags && _s.userInput ) {\n                this.events.callbacks.onEditTagFocus.call(this, tagElm)\n                this.editTag(tagElm)\n            }\n\n            this.toggleFocusClass(true)\n\n            if( _s.mode != 'select' )\n                this.trigger('dblclick', { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm) })\n        },\n\n        /**\n         *\n         * @param {Object} m an object representing the observed DOM changes\n         */\n        onInputDOMChange(m){\n            // iterate all DOM mutation\n            m.forEach(record => {\n                // only the ADDED nodes\n                record.addedNodes.forEach(addedNode => {\n                    // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'\n                    if( addedNode.outerHTML == '<div><br></div>' ){\n                        addedNode.replaceWith(document.createElement('br'))\n                    }\n\n                    // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)\n                    else if( addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector) ){\n                        let newlineText = document.createTextNode('')\n\n                        if( addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR' )\n                            newlineText  = document.createTextNode('\\n')\n\n                        // unwrap the useless div\n                        // chrome adds a BR at the end which should be removed\n                        addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0,-1)])\n                        placeCaretAfterNode(newlineText)\n                    }\n\n                    // if this is a tag\n                    else if( isNodeTag.call(this, addedNode) ){\n                        if( addedNode.previousSibling?.nodeType == 3 && !addedNode.previousSibling.textContent )\n                            addedNode.previousSibling.remove()\n\n                        // and it is the first node in a new line\n                        if( addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR' ){\n                            // allows placing the caret just before the tag, when the tag is the first node in that line\n                            addedNode.previousSibling.replaceWith('\\n' + ZERO_WIDTH_CHAR)\n\n                            let nextNode = addedNode.nextSibling, anythingAfterNode = '';\n\n                            while (nextNode) {\n                                anythingAfterNode += nextNode.textContent\n                                nextNode = nextNode.nextSibling;\n                            }\n\n                            // when hitting ENTER for new line just before an existing tag, but skip below logic when a tag has been addded\n                            anythingAfterNode.trim() && placeCaretAfterNode(addedNode.previousSibling)\n                        }\n\n                        // if previous sibling does not exists (meanning the addedNode is the first node in this.DOM.input)\n                        // or, if the previous sibling is also a tag, add a zero-space character before (to allow showing the caret in Chrome)\n                        else if( !addedNode.previousSibling || getSetTagData(addedNode.previousSibling) ){\n                            addedNode.before(ZERO_WIDTH_CHAR)\n                        }\n                    }\n                })\n\n                record.removedNodes.forEach(removedNode => {\n                    // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)\n                    if( removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)){\n                        this.removeTags(lastInputChild)\n                        this.fixFirefoxLastTagNoCaret()\n                    }\n                })\n            })\n\n            // get the last child only after the above DOM modifications\n            // check these scenarios:\n            // 1. after a single line, press ENTER once - should add only 1 BR\n            // 2. presss ENTER right before a tag\n            // 3. press enter within a text node before a tag\n            var lastInputChild = this.DOM.input.lastChild;\n\n            if( lastInputChild && lastInputChild.nodeValue == '' )\n                lastInputChild.remove()\n\n            // make sure the last element is always a BR\n            if( !lastInputChild || lastInputChild.nodeName != 'BR' ){\n                this.DOM.input.appendChild(document.createElement('br'))\n            }\n        },\n    }\n}\n\n", "import { sameStr, removeCollectionProp, omit, isObject, parseHTML, removeTextChildNodes, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag, injectAtCaret, placeCaretAfterNode, getSetTagData, fixCaretBetweenTags, logger } from './parts/helpers'\nimport DEFAULTS from './parts/defaults'\nimport _dropdown, { initDropdown } from './parts/dropdown'\nimport { getPersistedData, setPersistedData, clearPersistedData } from './parts/persist'\nimport TEXTS from './parts/texts'\nimport templates from './parts/templates'\nimport EventDispatcher from './parts/EventDispatcher'\nimport events, { triggerChangeEvent } from './parts/events'\n\n/**\n * @constructor\n * @param {Object} input    DOM element\n * @param {Object} settings settings object\n */\nfunction Tagify( input, settings ){\n    if( !input ){\n        logger.warn('input element not found', input)\n        // return an empty mock of all methods, so the code using tagify will not break\n        // because it might be calling methods even though the input element does not exist\n        const mockInstance = new Proxy(this, { get(){ return () => mockInstance } })\n        return mockInstance\n    }\n\n    if( input.__tagify ){\n        logger.warn('input element is already Tagified - Same instance is returned.', input)\n        return input.__tagify\n    }\n\n    extend(this, EventDispatcher(this))\n    this.isFirefox = (/firefox|fxios/i).test(navigator.userAgent) && !(/seamonkey/i).test(navigator.userAgent)\n    this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility\n\n    settings = settings || {};\n    this.getPersistedData = getPersistedData(settings.id)\n    this.setPersistedData = setPersistedData(settings.id)\n    this.clearPersistedData = clearPersistedData(settings.id)\n    this.applySettings(input, settings)\n\n    this.state = {\n        inputText: '',\n        editing : false,\n        composing: false,\n        actions : {},   // UI actions for state-locking\n        mixMode : {},\n        dropdown: {},\n        flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here\n    }\n\n    this.value = [] // tags' data\n\n    // events' callbacks references will be stores here, so events could be unbinded\n    this.listeners = {}\n\n    this.DOM = {} // Store all relevant DOM elements in an Object\n\n    this.build(input)\n    initDropdown.call(this)\n\n    this.getCSSVars()\n    this.loadOriginalValues()\n\n    this.events.customBinding.call(this)\n    this.events.binding.call(this)\n    input.autofocus && this.DOM.input.focus()\n    input.__tagify = this\n}\n\nTagify.prototype = {\n    _dropdown,\n    placeCaretAfterNode,\n    getSetTagData,\n    helpers: {sameStr, removeCollectionProp, omit, isObject, parseHTML, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag},\n\n    customEventsList : ['change', 'add', 'remove', 'invalid', 'input', 'paste', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],\n    dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'], // internal-uasge props\n\n    trim(text){\n        return this.settings.trim && text && typeof text == \"string\" ? text.trim() : text\n    },\n\n    // expose this handy utility function\n    parseHTML,\n\n    templates,\n\n    parseTemplate(template, data){\n        template = this.settings.templates[template] || template;\n        return parseHTML( template.apply(this, data) )\n    },\n\n    set whitelist( arr ){\n        const isArray = arr && Array.isArray(arr)\n        this.settings.whitelist = isArray ? arr : []\n        this.setPersistedData(isArray ? arr : [], 'whitelist')\n    },\n\n    get whitelist(){\n        return this.settings.whitelist\n    },\n\n    set userInput( state ){\n        this.settings.userInput = !!state\n        this.setContentEditable(!!state)\n    },\n\n    get userInput(){\n        return this.settings.userInput\n    },\n\n    generateClassSelectors(classNames){\n        for( let name in classNames ) {\n            let currentName = name;\n            Object.defineProperty(classNames, currentName + \"Selector\" , {\n                get(){ return \".\" + this[currentName].split(\" \")[0] }\n            })\n        }\n    },\n\n    applySettings( input, settings ){\n        DEFAULTS.templates = this.templates\n\n        var mixModeDefaults = {\n            dropdown: {\n                position: \"text\"\n            }\n        }\n\n        var mergedDefaults = extend({}, DEFAULTS, (settings.mode == 'mix' ? mixModeDefaults : {}));\n        var _s = this.settings = extend({}, mergedDefaults, settings)\n\n        _s.disabled = input.hasAttribute('disabled')\n        _s.readonly = _s.readonly || input.hasAttribute('readonly')\n        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\")\n        _s.required = input.hasAttribute('required')\n\n        this.generateClassSelectors(_s.classNames)\n\n        if ( _s.dropdown.includeSelectedTags === undefined )\n            _s.dropdown.includeSelectedTags = _s.duplicates;\n\n        if( this.isIE )\n            _s.autoComplete = false; // IE goes crazy if this isn't false\n\n        [\"whitelist\", \"blacklist\"].forEach(name => {\n            var attrVal = input.getAttribute('data-' + name)\n            if( attrVal ){\n                attrVal = attrVal.split(_s.delimiters)\n                if( attrVal instanceof Array )\n                    _s[name] = attrVal\n            }\n        })\n\n        // backward-compatibility for old version of \"autoComplete\" setting:\n        if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\n            _s.autoComplete = DEFAULTS.autoComplete\n            _s.autoComplete.enabled = settings.autoComplete\n        }\n\n        if( _s.mode == 'mix' ){\n            _s.pattern = _s.pattern || /@/;\n            _s.autoComplete.rightKey = true\n            _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\n\n            // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n            // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n            // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n            if( _s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp) )\n                _s.dropdown.searchKeys.push(_s.tagTextProp)\n        }\n\n        if( input.pattern )\n            try { _s.pattern = new RegExp(input.pattern)  }\n            catch(e){}\n\n        // Convert the \"delimiters\" setting into a REGEX object\n        if( _s.delimiters ){\n            _s._delimiters = _s.delimiters;\n            try { _s.delimiters = new RegExp(this.settings.delimiters, \"g\") }\n            catch(e){}\n        }\n\n        if( _s.disabled )\n            _s.userInput = false;\n\n        this.TEXTS = {...TEXTS, ...(_s.texts || {})}\n\n        // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n        if( (_s.mode == 'select' && !settings.dropdown?.enabled) || !_s.userInput ){\n            _s.dropdown.enabled = 0\n        }\n\n        _s.dropdown.appendTarget = settings.dropdown?.appendTarget || document.body;\n\n\n        // get & merge persisted data with current data\n        let persistedWhitelist = this.getPersistedData('whitelist');\n\n        if( Array.isArray(persistedWhitelist))\n            this.whitelist = Array.isArray(_s.whitelist)\n                ? concatWithoutDups(_s.whitelist, persistedWhitelist)\n                : persistedWhitelist;\n    },\n\n    /**\n     * Returns a string of HTML element attributes\n     * @param {Object} data [Tag data]\n     */\n    getAttributes( data ){\n        var attrs = this.getCustomAttributes(data), s = '', k;\n\n        for( k in attrs )\n            s += \" \" + k + (data[k] !== undefined ? `=\"${attrs[k]}\"` : \"\");\n\n        return s;\n    },\n\n    /**\n     * Returns an object of attributes to be used for the templates\n     */\n    getCustomAttributes( data ){\n        // only items which are objects have properties which can be used as attributes\n        if( !isObject(data) )\n            return '';\n\n        var output = {}, propName;\n\n        for( propName in data ){\n            if( propName.slice(0,2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined )\n                output[propName] = escapeHTML(data[propName])\n        }\n        return output\n    },\n\n    setStateSelection(){\n        var selection = window.getSelection()\n\n        // save last selection place to be able to inject anything from outside to that specific place\n        var sel = {\n            anchorOffset: selection.anchorOffset,\n            anchorNode  : selection.anchorNode,\n            range       : selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)\n        }\n\n        this.state.selection = sel\n        return sel\n    },\n\n    /**\n     * Get specific CSS variables which are relevant to this script and parse them as needed.\n     * The result is saved on the instance in \"this.CSSVars\"\n     */\n    getCSSVars(){\n        var compStyle = getComputedStyle(this.DOM.scope, null)\n\n        const getProp = name => compStyle.getPropertyValue('--'+name)\n\n        function seprateUnitFromValue(a){\n            if( !a ) return {}\n            a = a.trim().split(' ')[0]\n            var unit  = a.split(/\\d+/g).filter(n=>n).pop().trim(),\n                value = +a.split(unit).filter(n=>n)[0].trim()\n            return {value, unit}\n        }\n\n        this.CSSVars = {\n            tagHideTransition: (({value, unit}) => unit=='s' ? value * 1000 : value)(seprateUnitFromValue(getProp('tag-hide-transition')))\n        }\n    },\n\n    /**\n     * builds the HTML of this component\n     * @param  {Object} input [DOM element which would be \"transformed\" into \"Tags\"]\n     */\n    build( input ){\n        var DOM  = this.DOM,\n            labelWrapper = input.closest('label');\n\n        if( this.settings.mixMode.integrated ){\n            DOM.originalInput = null;\n            DOM.scope = input;\n            DOM.input = input;\n        }\n\n        else {\n            DOM.originalInput = input\n            DOM.originalInput_tabIndex = input.tabIndex\n            DOM.scope = this.parseTemplate('wrapper', [input, this.settings])\n            DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector)\n            input.parentNode.insertBefore(DOM.scope, input)\n            input.tabIndex = -1; // do not allow focus or typing directly, once tagified\n        }\n\n        // fixes tagify nested inside a <label> tag from getting focus when clicked on\n        if( labelWrapper )\n            labelWrapper.setAttribute('for', '')\n    },\n\n    /**\n     * revert any changes made by this component\n     */\n    destroy(){\n        this.events.unbindGlobal.call(this)\n        this.DOM.scope.parentNode.removeChild(this.DOM.scope)\n        this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex\n        delete this.DOM.originalInput.__tagify\n        this.dropdown.hide(true)\n        this.removeAllCustomListeners()\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\n    },\n\n    /**\n     * if the original input has any values, add them as tags\n     */\n    loadOriginalValues( value ){\n        var lastChild,\n            _s = this.settings\n\n        // temporarily block firing the \"change\" event on the original input until\n        // this method finish removing current value and adding a new one\n        this.state.blockChangeEvent = true\n\n        if( value === undefined ){\n            const persistedOriginalValue = this.getPersistedData('value')\n\n            // if the field already has a field, trust its the desired\n            // one to be rendered and do not use the persisted one\n            if( persistedOriginalValue && !this.DOM.originalInput.value )\n                value = persistedOriginalValue\n            else\n                value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value\n        }\n\n        this.removeAllTags()\n\n        if( value ){\n            if( _s.mode == 'mix' ){\n                this.parseMixTags(value)\n\n                lastChild = this.DOM.input.lastChild\n\n                // fixes a Chrome bug, when the last node in `mix-mode` is a tag, the caret appears at the far-top-top, outside the field\n                if( !lastChild || lastChild.tagName != 'BR' )\n                    this.DOM.input.insertAdjacentHTML('beforeend', '<br>')\n            }\n\n            else{\n                try{\n                    if( JSON.parse(value) instanceof Array )\n                        value = JSON.parse(value)\n                }\n                catch(err){}\n                this.addTags(value, true).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation))\n            }\n        }\n\n        else\n            this.postUpdate()\n\n        this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value\n    },\n\n    cloneEvent(e){\n        var clonedEvent = {}\n        for( var v in e )\n            if( v != 'path' )\n                clonedEvent[v] = e[v]\n        return clonedEvent\n    },\n\n    /**\n     * Toogle global loading state on/off\n     * Useful when fetching async whitelist while user is typing\n     * @param {Boolean} isLoading\n     */\n    loading( isLoading ){\n        this.state.isLoading = isLoading\n        // IE11 doesn't support toggle with second parameter\n        this.DOM.scope.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.scopeLoading)\n        return this\n    },\n\n    /**\n     * Toogle a tag loading state on/off\n     * @param {Boolean} isLoading\n     */\n    tagLoading( tagElm, isLoading ){\n        if( tagElm )\n            // IE11 doesn't support toggle with second parameter\n            tagElm.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.tagLoading)\n        return this\n    },\n\n    /**\n     * Toggles class on the main tagify container (\"scope\")\n     * @param {String} className\n     * @param {Boolean} force\n     */\n    toggleClass( className, force ){\n        if( typeof className == 'string' )\n            this.DOM.scope.classList.toggle(className, force)\n    },\n\n    toggleScopeValidation( validation ){\n        var isValid = validation === true || validation === undefined; // initially it is undefined\n\n        if( !this.settings.required && validation && validation === this.TEXTS.empty)\n            isValid = true\n\n        this.toggleClass(this.settings.classNames.tagInvalid, !isValid)\n        this.DOM.scope.title = isValid ? '' : validation\n    },\n\n    toggleFocusClass( force ){\n        this.toggleClass(this.settings.classNames.focus, !!force)\n    },\n\n    /**\n     * Sets the templates placeholder after initialization\n     * @param {String} str\n     */\n    setPlaceholder(str) {\n        ['data', 'aria'].forEach(p => this.DOM.input.setAttribute(`${p}-placeholder`, str))\n    },\n\n    triggerChangeEvent,\n\n    events,\n\n    fixFirefoxLastTagNoCaret(){\n        return // seems to be fixed in newer version of FF, so retiring below code (for now)\n        // var inputElm = this.DOM.input\n\n        // if( this.isFirefox && inputElm.childNodes.length && inputElm.lastChild.nodeType == 1 ){\n        //     inputElm.appendChild(document.createTextNode(\"\\u200b\"))\n        //     this.setRangeAtStartEnd(true, inputElm)\n        //     return true\n        // }\n    },\n\n    /** https://stackoverflow.com/a/59156872/104380\n     * @param {Boolean} start indicating where to place it (start or end of the node)\n     * @param {Object}  node  DOM node to place the caret at\n     */\n    setRangeAtStartEnd( start, node ){\n        if( !node ) return;\n\n        start = typeof start == 'number' ? start : !!start\n        node = node.lastChild || node;\n        var sel = document.getSelection()\n\n        // do not force caret placement if the current selection (focus) is on another element (not this tagify instance)\n        if( sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode) ) {\n            return true\n        }\n\n        try{\n            if( sel.rangeCount >= 1 ){\n                ['Start', 'End'].forEach(pos =>\n                    sel.getRangeAt(0)[\"set\" + pos](node, start ? start : node.length)\n                )\n            }\n        } catch(err){\n            console.warn(err)\n        }\n    },\n\n    insertAfterTag( tagElm, newNode ){\n        newNode = newNode || this.settings.mixMode.insertAfterTag;\n\n        if( !tagElm || !tagElm.parentNode || !newNode ) return\n\n        newNode = typeof newNode == 'string'\n            ? document.createTextNode(newNode)\n            : newNode\n\n        tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling)\n        return newNode\n    },\n\n    // compares all \"__originalData\" property values with the current \"tagData\" properties\n    // and returns \"true\" if something changed.\n    editTagChangeDetected(tagData) {\n        var originalData = tagData.__originalData;\n\n        for( var prop in originalData )\n            if( !this.dataProps.includes(prop) && tagData[prop] != originalData[prop] )\n                return true\n\n        return false; // not changed\n    },\n\n    // returns the node which has the actual tag's content\n    getTagTextNode(tagElm){\n        return tagElm.querySelector(this.settings.classNames.tagTextSelector)\n    },\n\n    // sets the text of a tag\n    setTagTextNode(tagElm, HTML){\n        this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML)\n    },\n\n    /**\n     * Enters a tag into \"edit\" mode\n     * @param {Node} tagElm the tag element to edit. if nothing specified, use last last\n     */\n    editTag( tagElm, opts ){\n        tagElm = tagElm || this.getLastTag()\n        opts = opts || {}\n\n        var _s = this.settings,\n            editableElm = this.getTagTextNode(tagElm),\n            tagIdx = this.getNodeIndex(tagElm),\n            tagData = getSetTagData(tagElm),\n            _CB = this.events.callbacks,\n            isValid = true,\n            isSelectMode = _s.mode == 'select'\n\n        // select mode is a bit different as clicking the tagify's content once will get into edit-mode if a value\n        // is already selected, and there cannot be a dropdown already open at this point.\n        !isSelectMode && this.dropdown.hide()\n\n        if( !editableElm ){\n            logger.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);\n            return;\n        }\n\n        if( tagData instanceof Object && \"editable\" in tagData && !tagData.editable )\n            return\n\n        // cache the original data, on the DOM node, before any modification ocurs, for possible revert\n        tagData = getSetTagData(tagElm, {\n            __originalData: extend({}, tagData),\n            __originalHTML: tagElm.cloneNode(true)\n        })\n        // re-set the tagify custom-prop on the clones element (because cloning removed it)\n        getSetTagData(tagData.__originalHTML, tagData.__originalData)\n\n        editableElm.setAttribute('contenteditable', true)\n        tagElm.classList.add( _s.classNames.tagEditing )\n\n        // because \"editTag\" method can be called manually, make sure that \"state.editing\" is set correctly\n        this.events.callbacks.onEditTagFocus.call(this, tagElm)\n\n        editableElm.addEventListener('click'            , _CB.onEditTagClick.bind(this, tagElm))\n        editableElm.addEventListener('blur'             , _CB.onEditTagBlur.bind(this, this.getTagTextNode(tagElm)))\n        editableElm.addEventListener('input'            , _CB.onEditTagInput.bind(this, editableElm))\n        editableElm.addEventListener('paste'            , _CB.onEditTagPaste.bind(this, editableElm))\n        editableElm.addEventListener('keydown'          , e => _CB.onEditTagkeydown.call(this, e, tagElm))\n        editableElm.addEventListener('compositionstart' , _CB.onCompositionStart.bind(this))\n        editableElm.addEventListener('compositionend'   , _CB.onCompositionEnd.bind(this))\n\n        if( !opts.skipValidation )\n            isValid = this.editTagToggleValidity(tagElm)\n\n        editableElm.originalIsValid = isValid\n\n        this.trigger(\"edit:start\", { tag:tagElm, index:tagIdx, data:tagData, isValid })\n\n        editableElm.focus()\n        !isSelectMode && this.setRangeAtStartEnd(false, editableElm) // place the caret at the END of the editable tag text\n\n        _s.dropdown.enabled === 0 && !isSelectMode && this.dropdown.show()\n        this.state.hasFocus = true\n\n        return this\n    },\n\n    /**\n     * If a tag is invalid, for any reason, set its class to \"not allowed\" (see defaults file)\n     * @param {Node} tagElm required\n     * @param {Object} tagData optional\n     * @returns true if valid, a string (reason) if not\n     */\n    editTagToggleValidity( tagElm, tagData ){\n        var tagData = tagData || getSetTagData(tagElm),\n            isValid;\n\n        if( !tagData ){\n            logger.warn(\"tag has no data: \", tagElm, tagData)\n            return;\n        }\n\n        isValid = !(\"__isValid\" in tagData) || tagData.__isValid === true\n\n        if( !isValid ){\n            this.removeTagsFromValue(tagElm)\n        }\n\n        this.update()\n\n        //this.validateTag(tagData);\n\n        tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid)\n        tagData.__isValid = isValid;\n\n        return tagData.__isValid\n    },\n\n    onEditTagDone(tagElm, tagData){\n        tagElm = tagElm || this.state.editing.scope\n        tagData = tagData || {}\n\n        var eventData = {\n            tag         : tagElm,\n            index       : this.getNodeIndex(tagElm),\n            previousData: getSetTagData(tagElm),\n            data        : tagData\n        }\n\n        var _s = this.settings\n\n        this.trigger(\"edit:beforeUpdate\", eventData, {cloneData:false})\n\n        this.state.editing = false;\n\n        delete tagData.__originalData\n        delete tagData.__originalHTML\n\n        // some scenarrios like in the one in the demos page with textarea that has 2 whitelists, one of the whitelist might be\n        // an array of objects with a property defined the same as the `tagTextProp` setting (if used) but another whitelist\n        // might be simpler - just an array of primitives.\n        function veryfyTagTextProp() {\n            var tagTextProp = tagData[_s.tagTextProp];\n\n            // 'tagTextProp' might also be the number 0 so checking for `undefined` here:\n            if( tagTextProp !== undefined ) {\n                tagTextProp += ''; // cast possible number into a string\n                return !!tagTextProp.trim?.()\n            }\n\n            if( !(_s.tagTextProp in tagData) )\n                return !!tagData.value\n        }\n\n        if( tagElm && veryfyTagTextProp() ){\n            tagElm = this.replaceTag(tagElm, tagData)\n            this.editTagToggleValidity(tagElm, tagData)\n\n            if( _s.a11y.focusableTags )\n                tagElm.focus()\n            else if( _s.mode != 'select' )\n                // place caret after edited tag\n                placeCaretAfterNode(tagElm)\n        }\n\n        else if(tagElm)\n            this.removeTags(tagElm)\n\n        this.trigger(\"edit:updated\", eventData)\n        this.dropdown.hide()\n\n        // check if any of the current tags which might have been marked as \"duplicate\" should be now un-marked\n        if( this.settings.keepInvalidTags )\n            this.reCheckInvalidTags()\n    },\n\n    /**\n     * Replaces an exisitng tag with a new one. Used for updating a tag's data\n     * @param {Object} tagElm  [DOM node to replace]\n     * @param {Object} tagData [data to create new tag from]\n     */\n    replaceTag(tagElm, tagData){\n        if( !tagData || tagData.value === '' || tagData.value === undefined )\n            tagData = tagElm.__tagifyTagData\n\n        // if tag is invalid, make the according changes in the newly created element\n        if( tagData.__isValid && tagData.__isValid != true )\n            extend( tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid) )\n\n        var newTagElm = this.createTagElem(tagData)\n\n        // update DOM\n        tagElm.parentNode.replaceChild(newTagElm, tagElm)\n        this.updateValueByDOMTags()\n        return newTagElm\n    },\n\n    /**\n     * update \"value\" (Array of Objects) by traversing all valid tags\n     */\n    updateValueByDOMTags(){\n        this.value.length = 0;\n\n        var clsNames = this.settings.classNames,\n            tagNotAllowedClassName = clsNames.tagNotAllowed.split(' ')[0],\n            skipNodesWithClassNames = [tagNotAllowedClassName, clsNames.tagHide];\n\n        [].forEach.call(this.getTagElms(), node => {\n            if ([...node.classList].some(cls => skipNodesWithClassNames.includes(cls))) return;\n            this.value.push( getSetTagData(node) )\n        })\n\n        this.update()\n    },\n\n    /**\n     * injects nodes/text at caret position, which is saved on the \"state\" when \"blur\" event gets triggered\n     * @param {Node} injectedNode [the node to inject at the caret position]\n     * @param {Object} selection [optional range Object. must have \"anchorNode\" & \"anchorOffset\"]\n     */\n    injectAtCaret( injectedNode, range ){\n        range = range || this.state.selection?.range\n\n        if(typeof injectedNode === 'string')\n            injectedNode = document.createTextNode(injectedNode)\n\n        if( !range && injectedNode ) {\n            this.appendMixTags(injectedNode)\n            return this;\n        }\n\n        let node = injectAtCaret(injectedNode, range)\n        this.setRangeAtStartEnd(false, node)\n\n        this.updateValueByDOMTags() // updates internal \"this.value\"\n        this.update() // updates original input/textarea\n\n        return this\n    },\n\n    /**\n     * input bridge for accessing & setting\n     * @type {Object}\n     */\n    input : {\n        set( value = '', updateDOM = true ){\n            var _s = this.settings,\n                hideDropdown = _s.dropdown.closeOnSelect\n\n            this.state.inputText = value\n\n            if( updateDOM ) {\n                this.DOM.input.innerHTML = escapeHTML(\"\"+value);\n                value && this.toggleClass(_s.classNames.empty, !this.DOM.input.innerHTML) // remove the \"empty\" (is exists) class only if a value was added\n            }\n\n            if( !value && hideDropdown )\n                this.dropdown.hide.bind(this)\n\n            this.input.autocomplete.suggest.call(this);\n            this.input.validate.call(this);\n\n        },\n\n        raw(){\n            return this.DOM.input.textContent\n        },\n\n        /**\n         * Marks the tagify's input as \"invalid\" if the value did not pass \"validateTag()\"\n         */\n        validate(){\n            var isValid = !this.state.inputText || this.validateTag({value:this.state.inputText}) === true;\n\n            this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid)\n\n            return isValid\n        },\n\n        // remove any child DOM elements that aren't of type TEXT (like <br>)\n        normalize( node, options ){\n            var clone = node || this.DOM.input, //.cloneNode(true),\n                v = [];\n\n            // when a text was pasted in FF, the \"this.DOM.input\" element will have <br> but no newline symbols (\\n), and this will\n            // result in tags not being properly created if one wishes to create a separate tag per newline.\n            clone.childNodes.forEach(n => n.nodeType==3 && v.push(n.nodeValue))\n            v = v.join(\"\\n\")\n\n            try{\n                // \"delimiters\" might be of a non-regex value, where this will fail (\"Tags With Properties\" example in demo page):\n                v = v.replace(/(?:\\r\\n|\\r|\\n)/g, this.settings.delimiters.source.charAt(0))\n            }\n            catch(err){}\n\n            v = v.replace(/\\s/g, ' ')  // replace NBSPs with spaces characters\n\n            return options?.trim ? this.trim(v) : v\n        },\n\n        /**\n         * suggest the rest of the input's value (via CSS \"::after\" using \"content:attr(...)\")\n         * @param  {String} s [description]\n         */\n        autocomplete : {\n            suggest( data ){\n                if( !this.settings.autoComplete.enabled ) return;\n\n                data = data || {value:''}\n                if (typeof data !== 'object') data = { value: data };\n\n                var suggestedText = this.dropdown.getMappedValue(data);\n\n                if( typeof suggestedText === 'number' ) return\n\n                var inputText = this.state.inputText.toLowerCase(),\n                    suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),\n                    suggestionTrimmed = suggestedText.substring(this.state.inputText.length);\n\n                if( !suggestedText || !this.state.inputText || suggestionStart != inputText ){\n                    this.DOM.input.removeAttribute(\"data-suggest\");\n                    delete this.state.inputSuggestion\n                }\n                else{\n                    this.DOM.input.setAttribute(\"data-suggest\", suggestionTrimmed);\n                    this.state.inputSuggestion = data\n                }\n            },\n\n            /**\n             * sets the suggested text as the input's value & cleanup the suggestion autocomplete.\n             * @param {String} s [text]\n             */\n            set( s ){\n                var dataSuggest = this.DOM.input.getAttribute('data-suggest'),\n                    suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);\n\n                if( suggestion ){\n                    if( this.settings.mode == 'mix' ){\n                        this.replaceTextWithNode( document.createTextNode(this.state.tag.prefix + suggestion) )\n                    }\n                    else{\n                        this.input.set.call(this, suggestion);\n                        this.setRangeAtStartEnd(false, this.DOM.input)\n                    }\n\n                    this.input.autocomplete.suggest.call(this);\n                    this.dropdown.hide();\n\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    },\n\n    /**\n     * returns the index of the the tagData within the \"this.value\" array collection.\n     * since values should be unique, it is suffice to only search by \"value\" property\n     * @param {Object} tagData\n     */\n    getTagIdx( tagData ){\n        return this.value.findIndex(item => item.__tagId == (tagData||{}).__tagId )\n    },\n\n    getNodeIndex( node ){\n        var index = 0;\n\n        if( node )\n            while( (node = node.previousElementSibling) )\n                index++;\n\n        return index;\n    },\n\n    getTagElms( ...classess ){\n        var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.')\n        return [].slice.call(this.DOM.scope.querySelectorAll(classname)) // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380\n    },\n\n    /**\n     * gets the last non-readonly, not-in-the-proccess-of-removal tag\n     */\n    getLastTag(){\n        var _sc = this.settings.classNames,\n            tagNodes = this.DOM.scope.querySelectorAll(`${_sc.tagSelector}:not(.${_sc.tagHide}):not([readonly])`);\n        return tagNodes[tagNodes.length - 1];\n    },\n\n    /**\n     * Searches if any tag with a certain value already exis\n     * @param  {String/Object} value [text value / tag data object]\n     * @param  {Boolean} caseSensitive\n     * @return {Number}\n     */\n    isTagDuplicate( value, caseSensitive, tagId ){\n        var dupsCount = 0;\n\n        for( let item of this.value ) {\n            let isSameStr = sameStr( this.trim(\"\"+value), item.value, caseSensitive );\n            if( isSameStr && tagId != item.__tagId )\n                dupsCount++;\n        }\n\n        return dupsCount\n    },\n\n    getTagIndexByValue( value ){\n        var indices = [],\n            isCaseSensitive = this.settings.dropdown.caseSensitive;\n\n        this.getTagElms().forEach((tagElm, i) => {\n            if(  tagElm.__tagifyTagData && sameStr( this.trim(tagElm.__tagifyTagData.value), value, isCaseSensitive )  )\n                indices.push(i)\n        })\n\n        return indices;\n    },\n\n    getTagElmByValue( value ){\n        var tagIdx = this.getTagIndexByValue(value)[0]\n        return this.getTagElms()[tagIdx]\n    },\n\n    /**\n     * Temporarily marks a tag element (by value or Node argument)\n     * @param  {Object} tagElm [a specific \"tag\" element to compare to the other tag elements siblings]\n     */\n    flashTag( tagElm ){\n        if( tagElm ){\n            tagElm.classList.add(this.settings.classNames.tagFlash)\n            setTimeout(() => { tagElm.classList.remove(this.settings.classNames.tagFlash) }, 100)\n        }\n    },\n\n    /**\n     * checks if text is in the blacklist\n     */\n    isTagBlacklisted( v ){\n        v = this.trim(v.toLowerCase());\n        return this.settings.blacklist.filter(x => (\"\"+x).toLowerCase() == v).length;\n    },\n\n    /**\n     * checks if text is in the whitelist\n     */\n    isTagWhitelisted( v ){\n        return !!this.getWhitelistItem(v)\n        /*\n        return this.settings.whitelist.some(item =>\n            typeof v == 'string'\n                ? sameStr(this.trim(v), (item.value || item))\n                : sameStr(JSON.stringify(item), JSON.stringify(v))\n        )\n        */\n    },\n\n    /**\n     * Returns the first whitelist item matched, by value (if match found)\n     * @param {String} value [text to match by]\n     */\n    getWhitelistItem( value, prop, whitelist ){\n        var result,\n            prop = prop || 'value',\n            _s = this.settings,\n            whitelist = whitelist || _s.whitelist;\n\n        whitelist.some(_wi => {\n            // whitelist item value. Can be either a String, Number or an Object (with a `value` property)\n            var _wiv = typeof _wi == 'object' ? (_wi[prop] || _wi.value) : _wi,\n                isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim)\n\n            if( isSameStr ){\n                result = typeof _wi == 'object' ? _wi : {value:_wi}\n                return true\n            }\n        })\n\n        // first iterate the whitelist, try find matches by \"value\" and if that fails\n        // and a \"tagTextProp\" is set to be other than \"value\", try that also\n        if( !result && prop == 'value' && _s.tagTextProp != 'value' ){\n            // if found, adds the first which matches\n            result = this.getWhitelistItem(value, _s.tagTextProp, whitelist)\n        }\n\n        return result\n    },\n\n    /**\n     * validate a tag object BEFORE the actual tag will be created & appeneded\n     * @param  {String} s\n     * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]\n     * @return {Boolean/String}  [\"true\" if validation has passed, String for a fail]\n     */\n    validateTag( tagData ){\n        var _s = this.settings,\n            // when validating a tag in edit-mode, need to take \"tagTextProp\" into consideration\n            prop = \"value\" in tagData ? \"value\" : _s.tagTextProp,\n            v = this.trim(tagData[prop] + \"\");\n\n        // check for definitive empty value\n        if( !(tagData[prop]+\"\").trim() )\n            return this.TEXTS.empty;\n\n        // check if pattern should be used and if so, use it to test the value\n        if( _s.mode != 'mix' && _s.pattern && _s.pattern instanceof RegExp && !(_s.pattern.test(v)) )\n            return this.TEXTS.pattern;\n\n        // check for duplicates\n        if( !_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId) )\n            return this.TEXTS.duplicate;\n\n        if( this.isTagBlacklisted(v) || (_s.enforceWhitelist && !this.isTagWhitelisted(v)) )\n            return this.TEXTS.notAllowed;\n\n        if( _s.validate )\n            return _s.validate(tagData)\n\n        return true\n    },\n\n    getInvalidTagAttrs(tagData, validation){\n        return {\n            \"aria-invalid\" : true,\n            \"class\": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),\n            \"title\": validation\n        }\n    },\n\n    hasMaxTags(){\n        return this.value.length >= this.settings.maxTags\n            ? this.TEXTS.exceed\n            : false\n    },\n\n    setReadonly( toggle, attrribute ){\n        var _s = this.settings\n\n        this.DOM.scope.contains(document.activeElement) && document.activeElement.blur() // exit possible edit-mode\n        _s[attrribute || 'readonly'] = toggle\n        this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true)\n\n        this.settings.userInput = true;\n        this.setContentEditable(!toggle)\n    },\n\n    setContentEditable(state){\n        this.DOM.input.contentEditable = state\n        this.DOM.input.tabIndex = !!state ? 0 : -1;\n    },\n\n    setDisabled( isDisabled ){\n        this.setReadonly(isDisabled, 'disabled')\n    },\n\n    /**\n     * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words\n     * so each item should be iterated on and a tag created for.\n     * @return {Array} [Array of Objects]\n     */\n    normalizeTags( tagsItems ){\n        var {whitelist, delimiters, mode, tagTextProp} = this.settings,\n            whitelistMatches = [],\n            whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,\n            // checks if this is a \"collection\", meanning an Array of Objects\n            isArray = Array.isArray(tagsItems),\n            isCollection = isArray && tagsItems[0].value,\n            mapStringToCollection = s => (s+\"\").split(delimiters).reduce((acc, v) => {\n                const trimmed = this.trim(v)\n                trimmed && acc.push({ [tagTextProp]:trimmed, value:trimmed })\n                return acc\n            }, [])\n\n        if( typeof tagsItems == 'number' )\n            tagsItems = tagsItems.toString()\n\n        // if the argument is a \"simple\" String, ex: \"aaa, bbb, ccc\"\n        if( typeof tagsItems == 'string' ){\n            if( !tagsItems.trim() ) return [];\n\n            // go over each tag and add it (if there were multiple ones)\n            tagsItems = mapStringToCollection(tagsItems)\n        }\n\n        // if is an Array of Strings, convert to an Array of Objects\n        else if( isArray ){\n            // flatten the 2D array\n            tagsItems = tagsItems.reduce((acc, item) => {\n                if( isObject(item) ) {\n                    var itemCopy = extend({}, item)\n\n                    // if 'tagTextProp' property does not exist in the item, use `value` instead\n                    if(!(tagTextProp in itemCopy))\n                        tagTextProp = 'value'\n\n                    itemCopy[tagTextProp] = this.trim(itemCopy[tagTextProp])\n\n                    // discard empty tags but allow `0` as a valid value\n                    if( itemCopy[tagTextProp] || itemCopy[tagTextProp] === 0 )\n                        acc.push(itemCopy) // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))\n                }\n\n                else if(item) {\n                    acc.push( ...mapStringToCollection(item) )\n                }\n\n                return acc\n            }, [])\n        }\n\n        // search if the tag exists in the whitelist as an Object (has props),\n        // to be able to use its properties.\n        // skip matching collections with whitelist items as they are considered \"whole\"\n        if( whitelistWithProps && !isCollection ){\n            tagsItems.forEach(item => {\n                var whitelistMatchesValues = whitelistMatches.map(a=>a.value)\n\n                // if suggestions are shown, they are already filtered, so it's easier to use them,\n                // because the whitelist might also include items which have already been added\n                var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], { exact:true })\n\n                if( !this.settings.duplicates )\n                    // also filter out items which have already been matched in previous iterations\n                    filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value))\n\n                // get the best match out of list of possible matches.\n                // if there was a single item in the filtered list, use that one\n                var matchObj = filteredList.length > 1\n                    ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList)\n                    : filteredList[0]\n\n                if( matchObj && matchObj instanceof Object ){\n                    whitelistMatches.push( matchObj ) // set the Array (with the found Object) as the new value\n                }\n                else if( mode != 'mix' ){\n                    if( item.value == undefined )\n                        item.value = item[tagTextProp]\n                    whitelistMatches.push(item)\n                }\n            })\n\n            if( whitelistMatches.length )\n                tagsItems = whitelistMatches\n        }\n\n        return tagsItems;\n    },\n\n    /**\n     * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags\n     * https://stackoverflow.com/a/57598892/104380\n     * @param {String} s\n     */\n    parseMixTags( s ){\n        var {mixTagsInterpolator, duplicates, transformTag, enforceWhitelist, maxTags, tagTextProp} = this.settings,\n            tagsDataSet = [];\n\n        s = s.split(mixTagsInterpolator[0]).map((s1, i) => {\n            var s2 = s1.split(mixTagsInterpolator[1]),\n                preInterpolated = s2[0],\n                maxTagsReached = tagsDataSet.length == maxTags,\n                textProp,\n                tagData,\n                tagElm;\n\n            try{\n                // skip numbers and go straight to the \"catch\" statement\n                if( preInterpolated == +preInterpolated )\n                    throw Error\n                tagData = JSON.parse(preInterpolated)\n            } catch(err){\n                tagData = this.normalizeTags(preInterpolated)[0] || {value:preInterpolated}\n            }\n\n            transformTag.call(this, tagData)\n\n            if( !maxTagsReached   &&\n                s2.length > 1   &&\n                (!enforceWhitelist || this.isTagWhitelisted(tagData.value))   &&\n                !(!duplicates && this.isTagDuplicate(tagData.value)) ){\n\n                // in case \"tagTextProp\" setting is set to other than \"value\" and this tag does not have this prop\n                textProp = tagData[tagTextProp] ? tagTextProp : 'value'\n                tagData[textProp] = this.trim(tagData[textProp])\n\n                tagElm = this.createTagElem(tagData)\n                tagsDataSet.push( tagData )\n                tagElm.classList.add(this.settings.classNames.tagNoAnimation)\n\n                s2[0] = tagElm.outerHTML //+ \"&#8288;\"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)\n                this.value.push(tagData)\n            }\n            else if(s1)\n                return i ? mixTagsInterpolator[0] + s1 : s1\n\n            return s2.join('')\n        }).join('')\n\n        this.DOM.input.innerHTML = s\n        this.DOM.input.appendChild(document.createTextNode(''))\n        this.DOM.input.normalize()\n\n        var tagNodes = this.getTagElms()\n\n        tagNodes.forEach((elm, idx) => getSetTagData(elm,  tagsDataSet[idx]))\n        this.update({withoutChangeEvent:true})\n\n        fixCaretBetweenTags(tagNodes, this.state.hasFocus)\n        return s\n    },\n\n    /**\n     * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)\n     * First there *has* to be a \"this.state.tag\" which is a string that was just typed and is staring with a prefix\n     */\n    replaceTextWithNode( newWrapperNode, strToReplace ){\n        if( !this.state.tag && !strToReplace ) return;\n\n        strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;\n        var idx, nodeToReplace,\n            selection = this.state.selection || window.getSelection(),\n            nodeAtCaret = selection.anchorNode,\n            firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;\n\n        // STEP 1: ex. replace #ba with the tag \"bart\" where \"|\" is where the caret is:\n        // CURRENT STATE: \"foo #ba #ba| #ba\"\n\n        // split the text node at the index of the caret\n        nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset)\n\n        // node 0: \"foo #ba #ba|\"\n        // node 1: \" #ba\"\n\n        // get index of LAST occurence of \"#ba\"\n        idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace)\n\n        if( idx == -1 ) return true;\n\n        nodeToReplace = nodeAtCaret.splitText(idx)\n\n        // node 0: \"foo #ba \"\n        // node 1: \"#ba\"    <- nodeToReplace\n\n        newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace)\n\n        // must NOT normalize contenteditable or it will cause unwanted issues:\n        // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7\n        // nodeAtCaret.parentNode.normalize()\n\n        return true;\n    },\n\n    /**\n     * Validate a tag's data and create a new tag node\n     * @param {*} tagData\n     * @param {*} options\n     * @returns Object\n     */\n    prepareNewTagNode(tagData, options) {\n        options = options || {}\n\n        var tagElm,\n            _s = this.settings,\n            aggregatedInvalidInput = [],\n            tagElmParams = {},\n            originalData = Object.assign({}, tagData, {value:tagData.value+\"\"});\n\n        // shallow-clone tagData so later modifications will not apply to the source\n        tagData = Object.assign({}, originalData)\n        _s.transformTag.call(this, tagData)\n\n        tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData)\n\n        if( tagData.__isValid !== true ){\n            if( options.skipInvalid )\n                return\n\n            // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,\n            // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored\n            extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {__preInvalidData:originalData})\n\n            if( tagData.__isValid == this.TEXTS.duplicate )\n                // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of\n                this.flashTag( this.getTagElmByValue(tagData.value) )\n\n            if( !_s.createInvalidTags ){\n                aggregatedInvalidInput.push(tagData.value)\n                return\n            }\n        }\n\n        if( 'readonly' in tagData ){\n            if( tagData.readonly )\n                tagElmParams[\"aria-readonly\"] = true\n            // if \"readonly\" is \"false\", remove it from the tagData so it won't be added as an attribute in the template\n            else\n                delete tagData.readonly\n        }\n\n        // Create tag HTML element\n        tagElm = this.createTagElem(tagData, tagElmParams)\n\n        return {tagElm, tagData, aggregatedInvalidInput}\n    },\n\n    /**\n     * Logic to happen once a tag has just been injected into the DOM\n     * @param {Node} tagElm\n     * @param {Object} tagData\n     */\n    postProcessNewTagNode(tagElm, tagData) {\n        var _s = this.settings,\n            isValid = tagData.__isValid;\n\n        if( isValid && isValid === true ){\n            // update state\n            this.value.push(tagData)\n        }\n        else{\n            this.trigger('invalid', {data:tagData, index:this.value.length, tag:tagElm, message:isValid})\n            if( !_s.keepInvalidTags )\n                // remove invalid tags (if \"keepInvalidTags\" is set to \"false\")\n                setTimeout(() => this.removeTags(tagElm, true), 1000)\n        }\n\n        this.dropdown.position() // reposition the dropdown because the just-added tag might cause a new-line\n    },\n\n    /**\n     * For selecting a single option (not used for multiple tags, but for \"mode:select\" only)\n     * @param {Object} tagElm   Tag DOM node\n     * @param {Object} tagData  Tag data\n     */\n    selectTag( tagElm, tagData ){\n        var _s = this.settings\n\n        if( _s.enforceWhitelist && !this.isTagWhitelisted(tagData.value) )\n            return\n\n        // this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true)\n\n        // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking \"TAB\")\n        if( this.state.actions.selectOption )\n            setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input))\n\n        var lastTagElm = this.getLastTag()\n\n        if( lastTagElm )\n            this.replaceTag(lastTagElm, tagData)\n        else\n            this.appendTag(tagElm)\n\n        // if( _s.enforceWhitelist )\n        //     this.setContentEditable(false);\n\n        this.value[0] = tagData\n        this.update()\n        this.trigger('add', { tag:tagElm, data:tagData })\n\n        return [tagElm]\n    },\n\n    /**\n     * add an empty \"tag\" element in an editable state\n     */\n    addEmptyTag( initialData ){\n        var tagData = extend({ value:\"\" }, initialData || {}),\n            tagElm = this.createTagElem(tagData)\n\n        getSetTagData(tagElm, tagData)\n\n        // add the tag to the component's DOM\n        this.appendTag(tagElm)\n        this.editTag(tagElm, {skipValidation:true})\n        this.toggleFocusClass(true)\n    },\n\n    /**\n     * add a \"tag\" element to the \"tags\" component\n     * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\n     * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]\n     * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]\n     * @return {Array} Array of DOM elements (tags)\n     */\n    addTags( tagsItems, clearInput, skipInvalid ){\n        var tagElems = [],\n            _s = this.settings,\n            aggregatedInvalidInput = [],\n            frag = document.createDocumentFragment(),\n            addedTags = []; // all tags, also invalid. this is used for firing the `add` event\n\n        if( !tagsItems || tagsItems.length == 0 ){\n            return tagElems\n        }\n\n        // converts Array/String/Object to an Array of Objects\n        tagsItems = this.normalizeTags(tagsItems)\n\n        switch( _s.mode ){\n            case 'mix': return this.addMixTags(tagsItems)\n            case 'select': {\n                clearInput = false\n                this.removeAllTags()\n            }\n        }\n\n        this.DOM.input.removeAttribute('style')\n\n        tagsItems.forEach(tagData => {\n            const newTagNode = this.prepareNewTagNode(tagData, {skipInvalid: skipInvalid || _s.skipInvalid});\n\n            if( !newTagNode) return;\n\n            const tagElm = newTagNode.tagElm;\n\n            tagData = newTagNode.tagData\n            aggregatedInvalidInput = newTagNode.aggregatedInvalidInput\n\n            tagElems.push(tagElm)\n\n            // mode-select overrides\n            if( _s.mode == 'select' ){\n                return this.selectTag(tagElm, tagData)\n            }\n\n            // add the tag to the component's DOM\n            // this.appendTag(tagElm)\n            frag.appendChild(tagElm)\n            this.postProcessNewTagNode(tagElm, tagData)\n            addedTags.push({tagElm, tagData})\n        })\n\n        this.appendTag(frag)\n\n        addedTags.forEach(({tagElm, tagData}) =>\n            this.trigger('add', {tag:tagElm, index:this.getTagIdx(tagData), data:tagData})\n        )\n\n        this.update()\n\n\n        if( tagsItems.length && clearInput ){\n            this.input.set.call(this, _s.createInvalidTags ? '' : aggregatedInvalidInput.join(_s._delimiters))\n            this.setRangeAtStartEnd(false, this.DOM.input)\n        }\n\n        // refilter hydrate the list\n        this.dropdown.refilter()\n        return tagElems\n    },\n\n    /**\n     * Adds a mix-content tag\n     * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings\n     */\n    addMixTags( tagsData ){\n        tagsData = this.normalizeTags(tagsData);\n\n        // flow for creating custom tags which aren't a part of the whitelist\n        if( tagsData[0].prefix || this.state.tag ){\n            return this.prefixedTextToTag(tagsData[0])\n        }\n\n        var frag = document.createDocumentFragment()\n\n        tagsData.forEach(tagData => {\n            const newTagNode = this.prepareNewTagNode(tagData)\n            frag.appendChild(newTagNode.tagElm)\n            this.insertAfterTag(newTagNode.tagElm)\n            this.postProcessNewTagNode(newTagNode.tagElm, newTagNode.tagData)\n        })\n\n        this.appendMixTags(frag)\n\n        return frag.children\n    },\n\n    appendMixTags( node ) {\n        var selection = !!this.state.selection;\n\n        // if \"selection\" exists, assumes intention of inecting the new tag at the last\n        // saved location of the caret inside \"this.DOM.input\"\n        if( selection ){\n            this.injectAtCaret(node)\n        }\n        // else, create a range and inject the new tag as the last child of \"this.DOM.input\"\n        else{\n            this.DOM.input.focus()\n            selection = this.setStateSelection()\n            selection.range.setStart(this.DOM.input, selection.range.endOffset)\n            selection.range.setEnd(this.DOM.input, selection.range.endOffset)\n            this.DOM.input.appendChild(node)\n\n            this.updateValueByDOMTags() // updates internal \"this.value\"\n            this.update() // updates original input/textarea\n        }\n    },\n\n    /**\n     * Adds a tag which was activly typed by the user\n     * @param {String/Array} tagData   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\n     */\n    prefixedTextToTag( tagData ){\n        var _s = this.settings,\n            tagElm,\n            newTag,\n            createdFromDelimiters = this.state.tag?.delimiters;\n\n        tagData.prefix = tagData.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source||_s.pattern)[0];\n\n        newTag = this.prepareNewTagNode(tagData)\n        tagElm = newTag.tagElm\n\n        // tries to replace a taged textNode with a tagElm, and if not able,\n        // insert the new tag to the END if \"addTags\" was called from outside\n        if( !this.replaceTextWithNode(tagElm) ){\n            this.DOM.input.appendChild(tagElm)\n        }\n\n        setTimeout(()=> tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300)\n\n        this.update()\n\n        if( !createdFromDelimiters ) {\n            var elm = this.insertAfterTag(tagElm) || tagElm;\n            // a timeout is needed when selecting a tag from the suggestions via mouse.\n            // Without it, it seems the caret is placed right after the tag and not after the\n            // node which was inserted after the tag (whitespace by default)\n            setTimeout(placeCaretAfterNode, 0, elm);\n        }\n\n        this.state.tag = null\n\n        this.postProcessNewTagNode(tagElm, newTag.tagData)\n\n        return tagElm\n    },\n\n    /**\n     * appened (validated) tag to the component's DOM scope\n     */\n    appendTag(tagElm){\n        var DOM = this.DOM,\n            insertBeforeNode = DOM.input;\n\n        //if( insertBeforeNode === DOM.input )\n            DOM.scope.insertBefore(tagElm, insertBeforeNode)\n        //else\n        //    DOM.scope.appendChild(tagElm)\n    },\n\n    /**\n     * creates a DOM tag element and injects it into the component (this.DOM.scope)\n     * @param  {Object}  tagData [text value & properties for the created tag]\n     * @param  {Object}  extraData [properties which are for the HTML template only]\n     * @return {Object} [DOM element]\n     */\n    createTagElem( tagData, extraData ){\n        tagData.__tagId = getUID()\n\n        var tagElm,\n            templateData = extend({}, tagData, { value:escapeHTML(tagData.value+\"\"), ...extraData });\n\n        // if( this.settings.readonly )\n        //     tagData.readonly = true\n\n        tagElm = this.parseTemplate('tag', [templateData, this])\n\n        // crucial for proper caret placement when deleting content. if textNodes are allowed as children of a tag element,\n        // a browser bug casues the caret to be misplaced inside the tag element (especially affects \"readonly\" tags)\n        removeTextChildNodes(tagElm)\n        // while( tagElm.lastChild.nodeType == 3 )\n        //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)\n\n        getSetTagData(tagElm, tagData)\n        return tagElm\n    },\n\n    /**\n     * re-check all invalid tags.\n     * called after a tag was edited or removed\n     */\n    reCheckInvalidTags(){\n        var _s = this.settings\n\n        this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {\n            var tagData = getSetTagData(tagElm),\n                hasMaxTags = this.hasMaxTags(),\n                tagValidation = this.validateTag(tagData),\n                isValid = tagValidation === true && !hasMaxTags;\n\n            if( _s.mode == 'select' )\n                this.toggleScopeValidation(tagValidation)\n\n            // if the tag has become valid\n            if( isValid ){\n                tagData = tagData.__preInvalidData\n                    ? tagData.__preInvalidData\n                    : { value:tagData.value }\n\n                return this.replaceTag(tagElm, tagData)\n            }\n\n            // if the tag is still invaild, set its title as such (reson of invalid might have changed)\n            tagElm.title = hasMaxTags || tagValidation\n        })\n    },\n\n    /**\n     * Removes a tag\n     * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]\n     * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]\n     * @param  {Number}             tranDuration    [Transition duration in MS]\n     * TODO: Allow multiple tags to be removed at-once\n     */\n    removeTags( tagElms, silent, tranDuration ){\n        var tagsToRemove,\n            _s = this.settings;\n\n        tagElms = tagElms && tagElms instanceof HTMLElement\n            ? [tagElms]\n            : tagElms instanceof Array\n                ? tagElms\n                : tagElms\n                    ? [tagElms]\n                    : [this.getLastTag()].filter(n => n)   // must filter because \"this.getLastTag()\" might be `undefined` if there are not tags\n\n        // normalize tagElms array values:\n        // 1. removing invalid items\n        // 2, if an item is String try to get the matching Tag HTML node\n        // 3. get the tag data\n        // 4. return a collection of Objects\n        tagsToRemove = tagElms.reduce((elms, tagElm) => {\n            if( tagElm && typeof tagElm == 'string')\n                tagElm = this.getTagElmByValue(tagElm)\n\n            var tagData = getSetTagData(tagElm);\n\n            if( tagElm && tagData && !tagData.readonly ) // make sure it's a tag and not some other node\n                // because the DOM node might be removed by async animation, the state will be updated while\n                // the node might still be in the DOM, so the \"update\" method should know which nodes to ignore\n                elms.push({\n                    node: tagElm,\n                    idx: this.getTagIdx(tagData), // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)\n                    data: getSetTagData(tagElm, {'__removed':true})\n                })\n\n            return elms\n        }, [])\n\n        tranDuration = typeof tranDuration == \"number\" ? tranDuration : this.CSSVars.tagHideTransition\n\n        if( _s.mode == 'select' ){\n            tranDuration = 0;\n            this.input.set.call(this)\n        }\n\n        // if only a single tag is to be removed.\n        // skip \"select\" mode because invalid tags are actually set to `this.value`\n        if( tagsToRemove.length == 1 && _s.mode != 'select' ){\n            if( tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed) )\n                silent = true\n        }\n\n        if( !tagsToRemove.length )\n            return;\n\n        return _s.hooks.beforeRemoveTag(tagsToRemove, {tagify:this})\n            .then(() => {\n                function removeNode( tag ){\n                    if( !tag.node.parentNode ) return\n\n                    tag.node.parentNode.removeChild(tag.node)\n\n                    if( !silent ){\n                        // this.removeValueById(tagData.__uid)\n                        this.trigger('remove', { tag:tag.node, index:tag.idx, data:tag.data })\n                        this.dropdown.refilter()\n                        this.dropdown.position()\n                        this.DOM.input.normalize() // best-practice when in mix-mode (safe to do always anyways)\n\n                        // check if any of the current tags which might have been marked as \"duplicate\" should be un-marked\n                        if( _s.keepInvalidTags )\n                            this.reCheckInvalidTags()\n\n                        // below code is unfinished. it should iterate all currently invalid edited tags, which their edits have not\n                        // changed the value yet, and should re-trigger the check, but since nothing has changed, it does not work...\n                        // this.getTagElms(_s.classNames.tagEditing).forEach( this.events.callbacks.onEditTagBlur.bind )\n                    }\n                    else if( _s.keepInvalidTags )\n                        this.trigger('remove', { tag:tag.node, index:tag.idx })\n                }\n\n                function animation( tag ){\n                    tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px'\n                    document.body.clientTop // force repaint for the width to take affect before the \"hide\" class below\n                    tag.node.classList.add(_s.classNames.tagHide)\n\n                    // manual timeout (hack, since transitionend cannot be used because of hover)\n                    setTimeout(removeNode.bind(this), tranDuration, tag)\n                }\n\n                if( tranDuration && tranDuration > 10 && tagsToRemove.length == 1 )\n                    animation.call(this, tagsToRemove[0])\n                else\n                    tagsToRemove.forEach(removeNode.bind(this))\n\n                // update state regardless of animation\n                if( !silent ){\n                    this.removeTagsFromValue(tagsToRemove.map(tag => tag.node))\n                    this.update() // update the original input with the current value\n\n                    if( _s.mode == 'select' && _s.userInput )\n                        this.setContentEditable(true);\n                }\n            })\n            .catch(reason => {})\n    },\n\n    removeTagsFromDOM(){\n        this.getTagElms().forEach(node => node.remove())\n    },\n\n    /**\n     * @param {Array/Node} tags to be removed from the this.value array\n     */\n    removeTagsFromValue( tags ){\n        tags = Array.isArray(tags) ? tags : [tags];\n\n        tags.forEach(tag => {\n            var tagData = getSetTagData(tag),\n                tagIdx = this.getTagIdx(tagData)\n\n            //  delete tagData.__removed\n\n            if( tagIdx > -1 )\n                this.value.splice(tagIdx, 1)\n        })\n    },\n\n    removeAllTags( opts ){\n        opts = opts || {}\n        this.value = []\n\n        if( this.settings.mode == 'mix' )\n            this.DOM.input.innerHTML = ''\n        else\n            this.removeTagsFromDOM()\n\n        this.dropdown.refilter()\n        this.dropdown.position()\n\n        if( this.state.dropdown.visible )\n            setTimeout(() => {\n                this.DOM.input.focus()\n            })\n\n        if( this.settings.mode == 'select' ){\n            this.input.set.call(this)\n            this.settings.userInput && this.setContentEditable(true)\n        }\n\n        // technically for now only \"withoutChangeEvent\" exists in the opts.\n        // if more properties will be added later, only pass what's needed to \"update\"\n        this.update(opts)\n    },\n\n    postUpdate(){\n        this.state.blockChangeEvent = false\n\n        var _s = this.settings,\n            classNames = _s.classNames,\n            hasValue = _s.mode == 'mix'\n                ? _s.mixMode.integrated\n                    ? this.DOM.input.textContent\n                    : this.DOM.originalInput.value.trim()\n                : this.value.length + this.input.raw.call(this).length;\n\n        this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags)\n        this.toggleClass(classNames.hasNoTags, !this.value.length)\n        this.toggleClass(classNames.empty, !hasValue)\n\n        // specifically the \"select mode\" might have the \"invalid\" classname set when the field is changed, so it must be toggled on add/remove/edit\n        if( _s.mode == 'select' ){\n            this.toggleScopeValidation(this.value?.[0]?.__isValid)\n        }\n    },\n\n    setOriginalInputValue( v ){\n        var inputElm = this.DOM.originalInput;\n\n        if( !this.settings.mixMode.integrated ){\n            inputElm.value = v\n            inputElm.tagifyValue = inputElm.value // must set to \"inputElm.value\" and not again to \"inputValue\" because for some reason the browser changes the string afterwards a bit.\n            this.setPersistedData(v, 'value')\n        }\n    },\n\n    /**\n     * update the origianl (hidden) input field's value\n     * see - https://stackoverflow.com/q/50957841/104380\n     */\n    update( args ){\n        const UPDATE_DELAY = 100\n        clearTimeout(this.debouncedUpdateTimeout)\n        this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY)\n        this.events.bindOriginaInputListener.call(this, UPDATE_DELAY)\n\n        function reallyUpdate() {\n            var inputValue = this.getInputValue();\n\n            this.setOriginalInputValue(inputValue)\n\n            if( (!this.settings.onChangeAfterBlur || !(args||{}).withoutChangeEvent) && !this.state.blockChangeEvent )\n                this.triggerChangeEvent()\n\n            this.postUpdate()\n        }\n    },\n\n    getInputValue(){\n        var value = this.getCleanValue();\n\n        return this.settings.mode == 'mix'\n            ? this.getMixedTagsAsString(value)\n            : value.length\n                ? this.settings.originalInputValueFormat\n                    ? this.settings.originalInputValueFormat(value)\n                    : JSON.stringify(value)\n                : \"\"\n    },\n\n    /**\n     * removes properties from `this.value` which are only used internally\n     */\n    getCleanValue(v){\n        return removeCollectionProp(v || this.value, this.dataProps);\n    },\n\n    getMixedTagsAsString(){\n        var result = \"\",\n            that = this,\n            _s = this.settings,\n            originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify,\n            _interpolator = _s.mixTagsInterpolator;\n\n        function iterateChildren(rootNode){\n            rootNode.childNodes.forEach((node) => {\n                if( node.nodeType == 1 ){\n                    const tagData = getSetTagData(node);\n\n                    if( node.tagName == 'BR'  ){\n                        result += \"\\r\\n\";\n                    }\n\n                    if( tagData && isNodeTag.call(that, node) ){\n                        if( tagData.__removed )\n                            return;\n                        else\n                            result += _interpolator[0] + originalInputValueFormat( omit(tagData, that.dataProps) ) + _interpolator[1]\n                    }\n                    else if( node.getAttribute('style') || ['B', 'I', 'U'].includes(node.tagName)  )\n                        result += node.textContent;\n\n                    else if( node.tagName == 'DIV' || node.tagName == 'P' ){\n                        result += \"\\r\\n\";\n                        //  if( !node.children.length && node.textContent )\n                        //  result += node.textContent;\n                        iterateChildren(node)\n                    }\n                }\n                else\n                    result += node.textContent;\n            })\n        }\n\n        iterateChildren(this.DOM.input)\n\n        return result;\n    }\n}\n\n// legacy support for changed methods names\nTagify.prototype.removeTag = Tagify.prototype.removeTags\n\nexport default Tagify\n", "import { extend, logger } from './helpers'\r\n\r\nexport default function EventDispatcher( instance ){\r\n    // Create a DOM EventTarget object\r\n    var target = document.createTextNode(''),\r\n        // keep track of all binded events & their callbacks to be able to completely remove all listeners of a speicific type\r\n        callbacksPerType = {}\r\n\r\n    function addRemove(op, events, cb){\r\n        if( cb )\r\n            events.split(/\\s+/g).forEach(ev => target[op + 'EventListener'].call(target, ev, cb))\r\n    }\r\n\r\n    // Pass EventTarget interface calls to DOM EventTarget object\r\n    return {\r\n        // unbinds all events\r\n        removeAllCustomListeners(){\r\n            Object.entries(callbacksPerType).forEach(([ev, cbArr]) => {\r\n                cbArr.forEach(cb => addRemove('remove', ev, cb))\r\n            })\r\n\r\n            callbacksPerType = {}\r\n        },\r\n\r\n        off(events, cb){\r\n            if( events ) {\r\n                if( cb )\r\n                    addRemove('remove', events, cb)\r\n                else\r\n                    // if `cb` argument was not specified then remove all listeners for the given event(s) types\r\n                    events.split(/\\s+/g).forEach(ev => {\r\n                        callbacksPerType[ev]?.forEach(cb => addRemove('remove', ev, cb))\r\n                        delete callbacksPerType[ev]\r\n                    })\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        on(events, cb){\r\n            if(cb && typeof cb == 'function') {\r\n                //track events callbacks to be able to remove them altogehter\r\n                events.split(/\\s+/g).forEach(ev => {\r\n                    if (Array.isArray(callbacksPerType[ev]) )\r\n                        callbacksPerType[ev].push(cb)\r\n                    else\r\n                        callbacksPerType[ev] = [cb]\r\n                })\r\n\r\n                addRemove('add', events, cb)\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        trigger(eventName, data, opts){\r\n            var e;\r\n\r\n            opts = opts || {\r\n                cloneData:true\r\n            }\r\n\r\n            if( !eventName ) return;\r\n\r\n            if( instance.settings.isJQueryPlugin ){\r\n                if( eventName == 'remove' ) eventName = 'removeTag' // issue #222\r\n                jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data])\r\n            }\r\n            else{\r\n                try {\r\n                    var eventData = typeof data === 'object'\r\n                        ? data\r\n                        : {value:data};\r\n\r\n                    eventData = opts.cloneData ? extend({}, eventData) : eventData\r\n                    eventData.tagify = this\r\n\r\n                    if( data.event )\r\n                        eventData.event = this.cloneEvent(data.event)\r\n\r\n                    // TODO: move the below to the \"extend\" function\r\n                    if( data instanceof Object )\r\n                        for( var prop in data )\r\n                            if(data[prop] instanceof HTMLElement)\r\n                                eventData[prop] = data[prop]\r\n\r\n                    e = new CustomEvent(eventName, {\"detail\":eventData})\r\n                }\r\n                catch(err){ logger.warn(err) }\r\n\r\n                target.dispatchEvent(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ZERO_WIDTH_UNICODE_CHAR", "t", "e", "i", "n", "logger", "isEnabled", "window", "TAGIFY_DEBUG", "log", "_len", "arguments", "length", "args", "Array", "_key", "console", "this", "_to_consumable_array", "warn", "sameStr", "s1", "s2", "caseSensitive", "trim", "toLowerCase", "removeCollectionProp", "collection", "unwantedProps", "isArray", "map", "v", "omit", "obj", "props", "p", "newObj", "indexOf", "parseHTML", "s", "DOMParser", "parseFromString", "body", "firstElementChild", "getfirstTextNode", "elm", "action", "nodeType", "escapeHTML", "replace", "isObject", "type", "Object", "prototype", "toString", "call", "split", "slice", "extend", "o", "o1", "o2", "copy", "a", "b", "key", "hasOwnProperty", "assign", "concatWithoutDups", "newArr", "existingObj", "_iteratorNormalCompletion", "_didIteratorError", "_iteratorError", "undefined", "_step", "_iterator", "Symbol", "iterator", "arr", "value", "_iteratorNormalCompletion1", "_didIteratorError1", "_iteratorError1", "_step1", "_iterator1", "item", "push", "includes", "err", "return", "unaccent", "String", "normalize", "isChromeAndroidBrowser", "test", "navigator", "userAgent", "getUID", "c", "crypto", "getRandomValues", "Uint8Array", "isNodeTag", "node", "classList", "contains", "settings", "classNames", "tag", "isWithinNodeTag", "closest", "tagSelector", "injectAtCaret", "content", "range", "selection", "getSelection", "getRangeAt", "document", "createTextNode", "deleteContents", "insertNode", "getSetTagData", "tagElm", "data", "override", "__tagifyTagData", "placeCaretAfterNode", "parentNode", "nextSibling", "sel", "rangeCount", "setStartAfter", "collapse", "removeAllRanges", "addRange", "fixCaretBetweenTags", "tags", "TagifyHasFocuse", "forEach", "previousSibling", "textNode", "before", "DEFAULTS", "delimiters", "pattern", "tagTextProp", "maxTags", "Infinity", "callbacks", "addTagOnBlur", "addTagOn", "onChangeAfterBlur", "duplicates", "whitelist", "blacklist", "enforceWhitelist", "userInput", "focusable", "keepInvalidTags", "createInvalidTags", "mixTagsAllowedAfter", "mixTagsInterpolator", "backspace", "skipInvalid", "pasteAsTags", "editTags", "clicks", "keepInvalid", "transformTag", "a11y", "focusableTags", "mixMode", "insertAfterTag", "autoComplete", "enabled", "rightKey", "tabKey", "namespace", "selectMode", "input", "focus", "tagNoAnimation", "tagInvalid", "tagNotAllowed", "scopeLoading", "hasMaxTags", "hasNoTags", "empty", "inputInvalid", "dropdown", "dropdownWrapper", "dropdownHeader", "dropdownFooter", "dropdownItem", "dropdownItemActive", "dropdownItemHidden", "dropdownItemSelected", "dropdownInital", "tagText", "tagX", "tagLoading", "tagEditing", "tagFlash", "tagHide", "classname", "maxItems", "searchKeys", "fuzzySearch", "accentedSearch", "includeSelectedTags", "highlightFirst", "closeOnSelect", "clearOnSelect", "position", "appendTarget", "hooks", "beforeRemoveTag", "Promise", "resolve", "beforePaste", "suggestionClick", "beforeKeyDown", "initDropdown", "_dropdown", "bind", "refs", "DOM", "__tagify", "_object_spread_props", "suggestionsMethods", "events", "binding", "bindUnbind", "_CB", "_CBR", "listeners", "onKeyDown", "onMouseOver", "onMouseLeave", "onClick", "onScroll", "state", "hasFocus", "composing", "_s", "selectedElm", "querySelector", "dropdownItemActiveSelector", "selectedElmData", "getSuggestionDataByNode", "isMixMode", "mode", "isSelectMode", "tagify", "then", "result", "preventDefault", "dropdownItems", "_this", "getAllSuggestionsRefs", "actionUp", "getNextOrPrevOption", "matches", "dropdownItemSelector", "highlightOption", "hide", "actions", "ArrowLeft", "shouldAutocompleteOnKey", "editing", "getMappedValue", "autocomplete", "set", "tagData", "suggestionElm", "selectOption", "addTags", "inputText", "catch", "scope", "raw", "charCodeAt", "removeTags", "setTimeout", "editTag", "ddItem", "target", "button", "pos", "scrollTop", "scrollHeight", "clientHeight", "trigger", "percentage", "Math", "round", "refilter", "query", "suggestedListItems", "filterListItems", "fill", "getAttribute", "selected", "next", "selectedIdx", "findIndex", "adjustScroll", "itemData", "className", "ddItemElm", "remove", "removeAttribute", "ddItemData", "suggest", "add", "setAttribute", "offsetTop", "event", "isNoMatch", "find", "normalizedTagData", "normalizeTags", "onEditTagDone", "__isValid", "toggleFocusClass", "addEventListener", "fillHeaderFooter", "once", "selectAll", "onlyRendered", "tagsToAdd", "suggestions", "options", "whitelistItem", "valueIsInWhitelist", "searchBy", "isDuplicate", "niddle", "l", "startsWithMatch", "exactMatch", "_searchKeys", "keys", "some", "k", "_sd", "exact", "reduce", "values", "every", "q", "isTagDuplicate", "exactMatchesList", "sortby", "list", "unshift", "d", "suggestionsCount", "filter", "_this1", "concat", "mapValueTo", "createListHTML", "sugegstionsList", "suggestion", "idx", "mappedValue", "templates", "apply", "join", "parseTemplate", "getHeaderRef", "getFooterRef", "querySelectorAll", "show", "firstListItem", "firstListItemValue", "noMatchListItem", "allowNewTags", "noWhitelist", "isManual", "dropdownItemNoMatch", "enable", "isLoading", "readonly", "clearTimeout", "dropdownHide__bindEventsTimeout", "visible", "setStateSelection", "render", "overrideManual", "_this_DOM", "removeEventListener", "removeChild", "flaggedTags", "baseOffset", "toggle", "getAppendTarget", "height", "clone", "ddHeight", "cloneNode", "style", "cssText", "appendChild", "HTMLContent", "dropdownContent", "innerHTML", "newHeaderElem", "newFooterElem", "headerRef", "footerRef", "replaceChild", "rect", "top", "bottom", "left", "width", "ancestorsOffsets", "isPlacedAbove", "cssTop", "cssLeft", "ddElm", "isRTL", "RTL", "isDefaultAppendTarget", "isSelfAppended", "appendTargetScrollTop", "pageYOffset", "root", "fullscreenElement", "webkitFullscreenElement", "documentElement", "viewportHeight", "positionTo", "max", "clientWidth", "innerWidth", "ddTarget", "r2", "r", "startContainer", "offset", "startOffset", "createRange", "setStart", "setEnd", "getBoundingClientRect", "right", "getCaretGlobalPosition", "offsetLeft", "accumulatedAncestorsScrollTop", "floor", "ceil", "placeAbove", "pageXOffset", "STORE_KEY", "TEXTS", "exceed", "duplicate", "notAllowed", "wrapper", "disabled", "required", "placeholder", "param", "title", "class", "getAttributes", "_t", "hasMore", "customBinding", "customEventsList", "name", "on", "mainEvents", "eventName", "main", "bindGlobal", "isJQueryPlugin", "jQuery", "originalInput", "removeAllTags", "keydown", "onKeydown", "click", "onClickScope", "dblclick", "onDoubleClickScope", "paste", "onPaste", "drop", "onDrop", "compositionstart", "onCompositionStart", "compositionend", "onCompositionEnd", "inputMutationObserver", "MutationObserver", "onInputDOMChange", "disconnect", "observe", "childList", "bindOriginaInputListener", "delay", "DELAY", "clearInterval", "originalInputValueObserverInterval", "setInterval", "observeOriginalInputValue", "unbind", "global", "isIE", "cb", "onWindowKeyDown", "onFocusBlur", "onClickAnywhere", "useCapture", "unbindGlobal", "_this_value_", "_this_value", "nodeTag", "targetIsTagNode", "isTargetXBtn", "isFocused", "lostFocus", "Date", "text", "textContent", "currentDisplayValue", "ddEnabled", "eventData", "relatedTarget", "isTargetSelectOption", "isTargetAddNewBtn", "addNew", "postUpdate", "triggerChangeEvent", "dropdownCanBeShown", "condition2", "loading", "firstTagNode", "getTagElms", "nextTag", "focusedElm", "activeElement", "isBelong", "isReadyOnlyTag", "hasAttribute", "nextElementSibling", "targetIsRemoveBtn", "deleteKeyTagDetected", "anchorOffset", "anchorNode", "prevAnchorSibling", "isCaretAfterTag", "el", "createElement", "enc", "innerText", "lastTagElems", "tagBeforeCaret", "tagElmToBeDeleted", "firstTextNodeBeforeTag", "isZWS", "nodeValue", "fromCharCode", "previousElementSibling", "_instanceof", "Element", "nodeName", "min", "isManualDropdown", "blur", "inputSuggestion", "onInput", "onMixTagsInput", "showSuggestions", "inputElm", "validation", "validateTag", "toggleScopeValidation", "isValid", "search", "rangeText", "match", "matchedPatternCount", "matchFlaggedTag", "matchDelimiters", "lastTagsCount", "tagsElems", "fragment", "createDocumentFragment", "remainingTagsValues", "inputType", "createTagElem", "childNodes", "setRangeAtStartEnd", "lastChild", "update", "withoutChangeEvent", "cloneRange", "focusNode", "endOffset", "lastIndexOf", "prefix", "onInputIE", "destroy", "tagifyValue", "loadOriginalValues", "isScope", "timeDiffFocus", "index", "getNodeIndex", "fixFirefoxLastTagNoCaret", "clipboardData", "pastedText", "getData", "onEditTagInput", "editableElm", "_obj", "tagElmIdx", "textValue", "dataForChangedProp", "_define_property", "__tagId", "editTagChangeDetected", "originalIsValid", "newValue", "onEditTagPaste", "newNode", "onEditTagClick", "onEditTagFocus", "onEditTagBlur", "isRelatedTargetNodeTag", "newTagData", "originalData", "__originalData", "hasChanged", "_obj1", "message", "onEditTagkeydown", "__originalHTML", "EDITED_TAG_BLUR_DELAY", "isEditingTag", "editable", "m", "record", "addedNodes", "addedNode", "outerHTML", "replaceWith", "newlineText", "nextNode", "anythingAfterNode", "removedNodes", "removedNode", "lastInputChild", "Tagify", "mockInstance", "Proxy", "get", "id", "instance", "callbacksPerType", "addRemove", "op", "ev", "removeAllCustomListeners", "entries", "cbArr", "off", "opts", "cloneData", "triggerHandler", "cloneEvent", "prop", "HTMLElement", "CustomEvent", "detail", "dispatchEvent", "isFirefox", "documentMode", "getPersistedData", "persistedData", "customKey", "localStorage", "getItem", "JSON", "parse", "setPersistedData", "setItem", "stringify", "Event", "clearPersistedData", "base", "removeItem", "applySettings", "build", "getCSSVars", "autofocus", "helpers", "dataProps", "template", "setContentEditable", "generateClassSelectors", "currentName", "defineProperty", "mergedDefaults", "attrVal", "RegExp", "_delimiters", "_object_spread", "texts", "persistedWhitelist", "attrs", "getCustomAttributes", "propName", "output", "compStyle", "getComputedStyle", "CSSVars", "tagHideTransition", "unit", "pop", "getPropertyValue", "labelWrapper", "integrated", "originalInput_tabIndex", "tabIndex", "inputSelector", "insertBefore", "blockChangeEvent", "persistedOriginalValue", "parseMixTags", "tagName", "insertAdjacentHTML", "lastOriginalValueReported", "clonedEvent", "toggleClass", "force", "setPlaceholder", "str", "changed", "bubbles", "simulated", "_valueTracker", "setValue", "random", "start", "getTagTextNode", "tagTextSelector", "setTagTextNode", "HTML", "getLastTag", "tagIdx", "skipValidation", "editTagToggleValidity", "removeTagsFromValue", "previousData", "replaceTag", "reCheckInvalidTags", "getInvalidTagAttrs", "newTagElm", "updateValueByDOMTags", "clsNames", "skipNodesWithClassNames", "cls", "injectedNode", "_this_state_selection", "appendMixTags", "updateDOM", "hideDropdown", "validate", "source", "charAt", "suggestedText", "suggestionStart", "substr", "suggestionTrimmed", "substring", "dataSuggest", "replaceTextWithNode", "getTagIdx", "classess", "_sc", "tagNodes", "tagId", "dupsCount", "done", "getTagIndexByValue", "indices", "isCaseSensitive", "getTagElmByValue", "flashTag", "isTagBlacklisted", "x", "isTagWhitelisted", "getWhitelistItem", "_wi", "_wiv", "setReadonly", "attrribute", "contentEditable", "setDisabled", "isDisabled", "tagsItems", "_this_settings", "whitelistMatches", "whitelistWithProps", "isCollection", "mapStringToCollection", "acc", "trimmed", "itemCopy", "whitelistMatchesValues", "filteredList", "filteredItem", "matchObj", "tagsDataSet", "textProp", "preInterpolated", "maxTagsReached", "Error", "newWrapperNode", "strToReplace", "nodeToReplace", "nodeAtCaret", "firstSplitOffset", "splitText", "prepareNewTagNode", "aggregatedInvalidInput", "tagElmParams", "__preInvalidData", "postProcessNewTagNode", "selectTag", "lastTagElm", "appendTag", "addEmptyTag", "initialData", "clearInput", "tagElems", "frag", "addedTags", "addMixTags", "newTagNode", "tagsData", "prefixedTextToTag", "children", "_this_state_tag", "newTag", "createdFromDelimiters", "insertBeforeNode", "extraData", "templateData", "textnode", "iter", "createNodeIterator", "NodeFilter", "SHOW_TEXT", "tagValidation", "tagElms", "silent", "tranDuration", "tagsToRemove", "elms", "__removed", "removeNode", "parseFloat", "clientTop", "reason", "removeTagsFromDOM", "splice", "hasValue", "setOriginalInputValue", "debouncedUpdateTimeout", "inputValue", "getInputValue", "getCleanValue", "getMixedTagsAsString", "originalInputValueFormat", "that", "_interpolator", "iterateChildren", "rootNode", "removeTag"]
}
